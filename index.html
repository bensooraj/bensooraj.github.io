<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Ben Sooraj - A journal of my learnings</title><meta name="keywords" content="golang, nodejs, mysql, docker, kubernetes, Ben Sooraj"/><meta name="next-head-count" content="4"/><link rel="preload" href="/_next/static/css/2c09a92627824155.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2c09a92627824155.css" data-n-g=""/><link rel="preload" href="/_next/static/css/3895b8d1746672df.css" as="style"/><link rel="stylesheet" href="/_next/static/css/3895b8d1746672df.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-7e73d61bce33e887.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6ebfa373a417a20.js" defer=""></script><script src="/_next/static/chunks/pages/index-6f0caec9c49745d1.js" defer=""></script><script src="/_next/static/hKGhU_jM7L7EOfUq9S-yp/_buildManifest.js" defer=""></script><script src="/_next/static/hKGhU_jM7L7EOfUq9S-yp/_ssgManifest.js" defer=""></script><script src="/_next/static/hKGhU_jM7L7EOfUq9S-yp/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><header class="Header_header__VYZ3G"><div class="max-width-container"><h2><a href="/">Ben Sooraj</a></h2><ul><li><a href="/about">About</a></li><li><a href="/blog">Blog</a></li></ul></div></header><main class="max-width-container main"><div><img src="/1597573125669.jpeg" alt="ben sooraj avatar" width="150" height="150" class="Home_img__Xgkmt"/><p>Hi üëãüèº, I&#x27;m Ben, a software engineer, a husband, a father and a voracious learner.</p></div><div class="Home_articleList__RW0kf"><h2 style="text-align:left;float:left">Latest Posts</h2><h4 style="text-align:right;float:right"><a href="/blog">Read all posts</a></h4><hr style="clear:both"/><div class="PostItem_postItem__8quwM"><h3 class="PostItem_date__BDd1B">17.02.2024</h3><h3 class="PostItem_title__U7sJ2"><a href="/blog/8-custom-local-domain-over-https">Custom Local Domain over HTTPS</a></h3></div><div class="PostItem_postItem__8quwM"><h3 class="PostItem_date__BDd1B">18.09.2023</h3><h3 class="PostItem_title__U7sJ2"><a href="/blog/7-go-compiler-func-inlining">Function Inlining in Golang</a></h3></div><div class="PostItem_postItem__8quwM"><h3 class="PostItem_date__BDd1B">28.05.2021</h3><h3 class="PostItem_title__U7sJ2"><a href="/blog/6-go-rpc">Go RPCs (Remote Procedure Calls)</a></h3></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"data":{"title":"Custom Local Domain over HTTPS","date":"2024-02-17T14:36:00+05:30","draft":false,"tags":["docker","nginx"]},"content":"\n# Custom Local Domain over HTTPS\n\n## Note\nThis is a documention for my own reference, so I can come back to it in the future either for setting up a new custom local domain over HTTPS using `docker` and `nginx`, or reverting back to the original state.\n\n## Steps\n### mkcert\nInstall mkcert:\n```bash\n# MacOS\n$ brew install mkcert\n\n# Create and install a local certificate authority (CA), trusted locally on your device.\n$ mkcert -install\n\n# List the root CA files.\n$ ls \"$(mkcert -CAROOT)\"\nrootCA-key.pem rootCA.pem\n\n# Create a trusted certificate.\n$ mkdir potato_cld \u0026\u0026 cd potato_cld\n$ mkcert potato.cld \"*.potato.cld\"\n\nCreated a new certificate valid for the following names üìú\n - \"potato.cld\"\n - \"*.potato.cld\"\n\nReminder: X.509 wildcards only go one level deep, so this won\\'t match a.b.potato.cld\n\nThe certificate is at \"./potato.cld+1.pem\" and the key at \"./potato.cld+1-key.pem\" ‚úÖ\n\nIt will expire on 11 May 2026 üóì\n```\n\nThe command `mkcert potato.cld \"*.potato.cld\"` above does two things:\n1. Generates a certificate for the hostname you've specified\n2. Lets `mkcert` (that you've added as a local CA) sign this certificate.\n\nNow, the certificate is ready and signed by a certificate authority that the browser trusts locally.\n### Configure DNS\n#### 1. Modify `/etc/hosts`\n\nThe simplest way to go about this is to update the `/etc/hosts` as shown below,\n```bash\n##\n# Host Database\n#\n# localhost is used to configure the loopback interface\n# when the system is booting.  Do not change this entry.\n##\n127.0.0.1\t      localhost\n255.255.255.255\tbroadcasthost\n::1             localhost\n\n127.0.0.1       potato.cld api.potato.cld api2.potato.cld\n```\n\nBut that is too simple. Let's crank up the complexity so I can learn something new - `dnsmasq`.\n\n#### 2. Install, configure and start the `dnsmasq`server\n\n\u003e `dnsmasq` is a lightweight DNS, TFTP, PXE, router advertisement and DHCP server. It is intended to provide coupled DNS and DHCP service to a LAN.\n\u003e \n\u003e Dnsmasq accepts DNS queries and either answers them from a small, local, cache or forwards them to a real, recursive, DNS server. It loads the contents of /etc/hosts so that local hostnames which do not appear in the global DNS can be resolved and also answers DNS queries for DHCP configured hosts. It can also act as the authoritative DNS server for one or more domains, allowing local names to appear in the global DNS. ...\n\u003e _source_: `man dnsmasq`\n\n```bash\n# Install\n$ brew install dnsmasq\n$ brew list dnsmasq\n/opt/homebrew/Cellar/dnsmasq/2.90/.bottle/etc/dnsmasq.conf\n/opt/homebrew/Cellar/dnsmasq/2.90/homebrew.dnsmasq.service\n/opt/homebrew/Cellar/dnsmasq/2.90/homebrew.mxcl.dnsmasq.plist\n/opt/homebrew/Cellar/dnsmasq/2.90/sbin/dnsmasq\n/opt/homebrew/Cellar/dnsmasq/2.90/share/man/man8/dnsmasq.8\n\n# Create a new directory and a `.conf` file:\n$ mkdir -p /Users/bsm/Development/dnsmasq.d\n$ touch /Users/bsm/Development/dnsmasq.d/dnsmasq.conf\n```\n\nWe will now uncomment and update the value of `conf-dir=` in `/opt/homebrew/etc/dnsmasq.conf` to point to `dnsmasq.conf` file we created above.\n\n```bash\n% cat $(brew --prefix)/etc/dnsmasq.conf | grep conf-dir\n#conf-dir=/opt/homebrew/etc/dnsmasq.d\nconf-dir=/Users/bsm/Development/dnsmasq.d/,*.conf\n#conf-dir=/opt/homebrew/etc/dnsmasq.d,.bak\n#conf-dir=/opt/homebrew/etc/dnsmasq.d/,*.conf\n```\n\nNext, edit `/Users/bsm/Development/dnsmasq.d/dnsmasq.conf` and add the line `address=/potato.cld/127.0.0.1`.\n```bash\n$ cat /Users/bensoorajmohan/Development/dnsmasq.d/dnsmasq.conf \naddress=/potato.cld/127.0.0.1\n\n```\n\nNow,\n```bash\n# start the `dnsmasq` service:\n$ sudo brew services start dnsmasq\n\nWarning: Taking root:admin ownership of some dnsmasq paths:\n  /opt/homebrew/Cellar/dnsmasq/2.90/sbin\n  /opt/homebrew/Cellar/dnsmasq/2.90/sbin/dnsmasq\n  /opt/homebrew/opt/dnsmasq\n  /opt/homebrew/opt/dnsmasq/sbin\n  /opt/homebrew/var/homebrew/linked/dnsmasq\n\nThis will require manual removal of these paths using `sudo rm` on\nbrew upgrade/reinstall/uninstall.\n==\u003e **Successfully started `dnsmasq` (label: homebrew.mxcl.dnsmasq)**\n\n# verify that the service is running:\n$ sudo brew services\n**Name  Status  User File**\nblack   none         \ndnsmasq started root /Library/LaunchDaemons/homebrew.mxcl.dnsmasq.plist\nunbound none\n```\n\n#### 3. Configure `resolv.conf`\n\nConfigure the DNS server to be used for the domain `potato.cld`:\n```shell\n# Make a new folder called /etc/resolver/, if it doesn't exist\n$ sudo mkdir -p /etc/resolver/\n# Create a new file with the name of the domain you want custom DNS settings for\n$ touch /etc/resolver/potato.cld\n# Set the nameserver that the domain should resolve to\n$ sudo tee /etc/resolver/potato.cld \u003e/dev/null \u003c\u003cEOF\nnameserver 127.0.0.1\nEOF\n\n# restart local dnsmasq service\n$ sudo brew services restart dnsmasq\nStopping `dnsmasq`... (might take a while)\n\n==\u003e **Successfully stopped `dnsmasq` (label: homebrew.mxcl.dnsmasq)**\nWarning: Taking root:admin ownership of some dnsmasq paths:\n  /opt/homebrew/Cellar/dnsmasq/2.90/sbin\n  /opt/homebrew/Cellar/dnsmasq/2.90/sbin/dnsmasq\n  /opt/homebrew/opt/dnsmasq\n  /opt/homebrew/opt/dnsmasq/sbin\n  /opt/homebrew/var/homebrew/linked/dnsmasq\nThis will require manual removal of these paths using `sudo rm` on\nbrew upgrade/reinstall/uninstall.\n==\u003e **Successfully started `dnsmasq` (label: homebrew.mxcl.dnsmasq)**\n```\n\n### Verify\n```bash\n$ dscacheutil -q host -a name potato.cld\n\nname: potato.cld\nip_address: 127.0.0.1\n\n# Verify the new resolver was picked up\n$ scutil --dns\nDNS configuration\n\nresolver #8\n  domain        : potato.cld\n  nameserver[0] : 127.0.0.1\n  flags         : Request A records, Request AAAA records\n  reach         : 0x00030002 (Reachable,Local Address,Directly Reachable Address)\n```\n\n## Docker and Nginx\n\nClone the git repository and start the docker containers:\n```bash\n$ git clone https://github.com/bensooraj/blog-artefact-custom-local-domain.git\n$ docker-compose up -d\n\n$ curl https://api.potato.cld/ok \n200 OK: api.potato.cld\n\n$ curl https://api2.potato.cld/ok\n200 OK: api2.potato.cld\n\n$ docker ps -a\n\nCONTAINER ID   IMAGE                   COMMAND                  CREATED         STATUS         PORTS                                      NAMES\nef88c504a751   nginx:latest            \"/docker-entrypoint.‚Ä¶\"   2 minutes ago   Up 2 minutes   0.0.0.0:80-\u003e80/tcp, 0.0.0.0:443-\u003e443/tcp   nginx\n39651f26920c   one_tls_whoami-goapi    \"./server\"               2 minutes ago   Up 2 minutes   8080/tcp, 0.0.0.0:8080-\u003e443/tcp            one_tls_whoami-goapi-1\na98caad7d4cb   one_tls_whoami-goapi2   \"./server\"               2 minutes ago   Up 2 minutes   8080/tcp, 0.0.0.0:8081-\u003e443/tcp            one_tls_whoami-goapi2-1\n\n$ docker logs nginx --tail=2\n192.168.65.1 - - [15/Feb/2024:09:54:17 +0000] \"GET /ok HTTP/1.1\" 200 23 \"-\" \"curl/8.1.2\" \"-\"\n192.168.65.1 - - [15/Feb/2024:09:54:18 +0000] \"GET /ok HTTP/1.1\" 200 24 \"-\" \"curl/8.1.2\" \"-\"\n\n$ docker logs one_tls_whoami-goapi-1 --tail=2\n2024/02/15 09:54:09 INFO server started on localhost. protocol=https port=443\n2024/02/15 09:54:17 INFO Header:  X-API-ServerName=api.potato.cld\n\n$ docker logs one_tls_whoami-goapi2-1 --tail=2                       \n2024/02/15 09:54:09 INFO server started on localhost. protocol=https port=443\n2024/02/15 09:54:18 INFO Header:  X-API-ServerName=api2.potato.cld\n```\n\nExplore the `nginx` configuration files:\n```bash\n$ cat nginx/conf/api2_potato_cld.conf\n\nserver {\n\tlisten 80;\n\tlisten [::]:80;\n\tserver_name api2.potato.cld;\n\n\treturn 301 https://api2.potato.cld$request_uri;\n}\n\nserver {\n\tlisten 443 ssl;\n\tlisten [::]:443 ssl;\n\n\tserver_name api2.potato.cld;\n\n\tssl_certificate /etc/nginx/ssl/potato.cld.pem;\n\tssl_certificate_key /etc/nginx/ssl/potato.cld-key.pem;\n\n\t# If they come here using HTTP, bounce them to the correct scheme\n\terror_page 497 https://$server_name:$server_port$request_uri;\n\n\terror_log /dev/stderr;\n\taccess_log /dev/stdout main;\n\n\tlocation / {\n\t\tproxy_set_header X-API-ServerName $server_name;\n\t\tproxy_set_header X-Forwarded-For $remote_addr;\n\t\tproxy_set_header Host $http_host;\n\t\tproxy_pass https://host.docker.internal:8081;\n\t}\n}\n```\n\n## References\n1. [How to use HTTPS for local development](https://web.dev/articles/how-to-use-local-https)\n2. [macOS: Using Custom DNS Resolvers](https://vninja.net/2020/02/06/macos-custom-dns-resolvers/)\n3. [Mastering NGINX Logs in Docker: From Novice to Ninja](https://karandeepsingh.ca/post/nginx-logs-and-docker-your-ultimate-guide/)\n4. [How to create local wildcard domains in MacOS using dnsmasq?](https://dev.to/timtsoitt/how-to-resolve-local-wildcard-domains-in-macos-h5e)\n5. [Gist: Never touch your local /etc/hosts file in OS X again](https://gist.github.com/ogrrd/5831371)\n6. [OS/X \"etc/resolver/dev\" isn't working - why not?](https://stackoverflow.com/questions/50914268/os-x-etc-resolver-dev-isnt-working-why-not)\n7. [Using Dnsmasq for local development on OS X](https://passingcuriosity.com/2013/dnsmasq-dev-osx/)\n8. [Local domains with HTTPS and Docker compose](https://medium.com/@TomVance/local-domains-with-https-469036775818)\n9. [Docker-Powered Web Development Utilizing HTTPS and Local Domain Names](https://betterprogramming.pub/docker-powered-web-development-utilizing-https-and-local-domain-names-a57f129e1c4d)\n10. [Setting up a custom domain for your local apps (Mac OS \u0026 Linux)](https://emmapopoola.medium.com/setting-up-a-custom-domain-for-your-local-apps-mac-os-linux-c68798722143)\n11. [Configure NGINX as a Reverse Proxy with Docker Compose file](https://umasrinivask.medium.com/configure-nginx-as-a-reverse-proxy-with-docker-compose-file-4ebba2b75c89)\n12. [How to Setup a Local DNS Server Using DNSMasq](https://stevessmarthomeguide.com/home-network-dns-dnsmasq/)\n","slug":"8-custom-local-domain-over-https"},{"data":{"title":"Function Inlining in Golang","date":"2023-09-18T10:00:00+05:30","draft":false,"tags":["golang"]},"content":"\nimport MDImage from '../../../components/MDImage.js';\n\n# Function Inlining in Golang\n\n## What is Inlining?\n\nInlining is a form of compiler optimisation where the compiler replaces a function call with the function's body to reduce the overhead of the function call. The following diagram crudely shows what this process looks like.\n\n\u003cMDImage src=\"/7/0_func_inlining.png\" alt=\"Function inlining illustration\" /\u003e\n\nLet's take an example Go program.\n\n```go\n// main.go\npackage main\n\nfunc main() {\n\tvar a int = 10\n\tvar b int = 20\n\t\n\tc := sum(a, b)\n\tprint(c)\n\t\n\td := difference(b, a)\n\tprint(d)\n}\n\nfunc sum(a int, b int) int {\n\treturn a + b\n}\n\nfunc difference(a int, b int) int {\n\treturn a - b\n}\n```\n\nBuild the above program using the following command,\n```sh\nGOOS=darwin GOARCH=amd64 go build -o expinline_darwin_amd64\n```\n\nTo understand inlining in practice, we will have to look at the assembly code generated by the above command and for that, we will have to disassemble the binary `expinline_darwin_amd64`.\n\nBefore we do that, let's look at the symbols (I am looking for the function names here),\n```sh\n$ objdump --syms expinline_darwin_amd64 | grep -E '_main.main|sum|difference'        \n0000000001057600 l     F __TEXT,__text _main.main\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n```\nYou will see no symbols for the functions `sum` and `difference`. To understand why this is the case, let's dig deeper into the assembly code,\n```sh\n$ objdump expinline_darwin_amd64 --disassemble-symbols=_main.main\n```\n\u003cMDImage src=\"/7/1_opt_and_inline_asm.jpeg\" alt=\"\" /\u003e\n\nSurprisingly, I see no function calls (`callq`) to `sum` or `difference`. It looks as if the compiler was smart enough to reduce the whole program to calling the print function on two absolute constants `30` (`a`+`b`) and `10` (`b`-`a`) denoted by `movl $30, %eax` and `movl $10, %eax` respectively, before the call to `print`.\n\nLet's turn off this compiler optimisation to preserve calculation logic and reevaluate the results.\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-N' -o expinline_darwin_amd64_no_op\n```\n\nAnd examine the `_main.main` symbol again,\n```sh\n$ objdump expinline_darwin_amd64_no_op --disassemble-symbols=_main.main\n```\n\u003cMDImage src=\"/7/2_no_opt_asm.jpeg\" alt=\"\" /\u003e\n\nNow you can observe that there is addition logic between the offsets `105762a` and `105763c`  and subtraction logic between the offsets `1057665` and `105767c`. Again, there are no function calls (`callq`) to `sum` or `difference`, indicating that they have been inlined into the caller `main()`.\n\nAlong with turning off the optimisation, `inlining` can also be turned off.\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-N -l' -o expinline_darwin_amd64_no_op_no_inline\n```\nIf you examine the symbols now, you can see the missing functions as well:\n```sh\n$ objdump --syms expinline_darwin_amd64_no_op_no_inline | grep -E '_main.main|sum|difference'\n00000000010576e0 l     F __TEXT,__text _main.difference\n0000000001057600 l     F __TEXT,__text _main.main\n00000000010576a0 l     F __TEXT,__text _main.sum\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n```\nAnd here's the disassembled code,\n\u003cMDImage src=\"/7/3_no_opt_no_inline_asm.jpeg\" alt=\"\" /\u003e\n\n## Why inline?\n\n### Improves performance by minimising the function call overheads\nThese overheads include stack manipulation, CPU register loading/unloading, branching, handling return values, etc.\n\nLet's perform a quick benchmark test to gauge the gain in performance. The following bench function calls the `sum` and `difference` functions,\n```go\n// main_bench_test.go\npackage main\n\nimport \"testing\"\n\nvar Result int\n\nfunc BenchmarkSpecialBinomialProduct(b *testing.B) {\n\tvar r int\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tr = sum(i, i+7) * difference(i+7, i)\n\t}\n\tResult = r\n}\n```\n\nRun it with all the default optimisations turned on,\n```sh\n$ go test -run='^$' -bench=. -benchmem -benchtime=10s -count=10 \u003e bench_with_inlining.txt\n```\n\nNow add the compiler directive `//go:noinline` just above the function definitions of `sum` and `difference` and rerun the bench,\n```sh\n$ go test -run='^$' -bench=. -benchmem -benchtime=10s -count=10 \u003e bench_with_no_inlining.txt\n```\n\nFinally, compare the results from the benchmark above,\n```sh\n$ benchstat {bench_with_no_inlining,bench_with_inlining}.txt\n```\n\u003cMDImage src=\"/7/4_benchstat.png\" alt=\"\" /\u003e\n\nAlbeit a contrived example, you can see a performance improvement of ~78%.\n\nTwo things to note about inlining.\n* It is a trade-off between space (increased binary size) and time (performance). This is because the function's body is copied to everywhere it is called.\n* It yields diminishing returns as the functions get larger or more complex because the call overhead to these functions becomes relatively negligible.\n\n### Augments escape analysis\n\nEscape analysis is a compiler optimisation technique that determines if a value can be on the stack frame for the function constructing it or if the value must ‚Äúescape‚Äù to the heap.\n\nLet's consider the following example,\n``` go\n// escape/main.go\npackage main\n\ntype Point struct {\n\tx, y int\n}\n\nfunc NewPoint(x, y int) *Point {\n\treturn \u0026Point{x, y} // 8:9\n}\n\nfunc main() {\n\tp1 := NewPoint(10, 20) // 12:16\n\tp2 := NewPoint(30, 40) // 13:16\n\t\n\tprint(p1.x, p2.y)\n}\n```\n\nBuild the above program with the `-m` compiler flag to print optimisation decisions,\n```sh\n$ go build -gcflags='-m=1' escape/main.go         \n# command-line-arguments\nescape/main.go:7:6: can inline NewPoint\nescape/main.go:11:6: can inline main\nescape/main.go:12:16: inlining call to NewPoint\nescape/main.go:13:16: inlining call to NewPoint\nescape/main.go:8:9: \u0026Point{...} escapes to heap\nescape/main.go:12:16: \u0026Point{...} does not escape\nescape/main.go:13:16: \u0026Point{...} does not escape\n```\n\nSince `NewPoint` is expanded inside the `main` function, the lifetimes of `Point{10, 20}` and `Point{30, 40}` are bound within the `main`'s scope. \n\nNow build with inlining turned off,\n```sh\n$ go build -gcflags='-m=1 -l' escape/main.go\n# command-line-arguments\nescape/main.go:8:9: \u0026Point{...} escapes to heap\n```\n\nEach call to `NewPoint(..)` will result in a `Point` object allocated to the heap memory.\n\n## How does the compiler do that?\n\nGo's compiler uses a combination of budget and cost to determine whether to inline a function. Every function has a cost compared against a budget (threshold). \n\nA function's cost is calculated using the complexity of the statements within the function body (one unit per node in the AST). And the budget changes from one release (40 in Go 1.6 | [src/cmd/compile/internal/gc/inl.go](https://github.com/golang/go/blob/7bc40ffb05d8813bf9b41a331b45d37216f9e747/src/cmd/compile/internal/gc/inl.go#L14)) to another (80 | [src/cmd/compile/internal/inline/inl.go](https://github.com/golang/go/blob/4be921d888d3a68c51e38d4c615a4438c7b2cb30/src/cmd/compile/internal/inline/inl.go#L47)).\n\nLet's take the following example,\n\u003cMDImage src=\"/7/5_cost_budget_midstack.jpeg\" alt=\"\" /\u003e\n\nFigures `a`, `b` and `c` represent the same program, each with slight modifications (green highlight) to demonstrate cost allocation and mid-stack inlining.\n\nLet's build the program in Figure `a` (output condensed for relevance),\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-m=2' midstack/main.go                      \n# command-line-arguments\nmidstack/main.go:30:6: can inline Sum with cost 4 as: func(int, int) int { return a + b }\nmidstack/main.go:23:6: can inline MidPoint with cost 28 as: func(Point, Point) Point { return Point{...} }\nmidstack/main.go:25:9: inlining call to Sum\nmidstack/main.go:26:9: inlining call to Sum\nmidstack/main.go:18:6: cannot inline PrintPoint: function too complex: cost 89 exceeds budget 80\nmidstack/main.go:20:13: inlining call to fmt.Println\nmidstack/main.go:10:6: cannot inline main: function too complex: cost 114 exceeds budget 80\nmidstack/main.go:13:26: inlining call to MidPoint\nmidstack/main.go:13:26: inlining call to Sum\nmidstack/main.go:13:26: inlining call to Sum\n```\n\nYou can see that each function has a cost assigned to it, which is compared against the budget (`80`) to decide whether the function can be inlined. The functions `MidPoint` (cost: `28`) and `Sum` (cost: `4`) are inline-able, whereas `PrintPoint` (cost: `89`) and `main` (cost: `114`) are not.\n\nI will also use this example to showcase the two forms of inlining,\n1. Leaf inlining\n\t- Earlier, only functions that did not call other functions (bottom of the call stack) were eligible for inlining. Once a leaf function is inlined, the resulting code can be inlined into its caller, a recursive process.\n\t- For example, `Sum` (a leaf function) gets inlined into `MidPoint`. Next, `MidPoint` (a leaf function now) gets inlined into `main`.\n2. Mid-stack inlining\n\t- Now, non-leaf functions are also eligible for inlining.\n\t- For example, in Figure `c`, the function `Sum` is marked with the directive `//go:noinline`, making it non-eligible for inlining. Even though `MidPoint` calls `Sum`, it is allocated a cost of `76`, making it eligible for inlining.\n\n## References\n1. [Inlining optimisations in Go - Dave Cheney](https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-5-4053)\n2. [Mid-stack inlining in Go - Dave Cheney](https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go#easy-footnote-bottom-1-4076)\n3. [Inlining - bright victories and hidden defeats](/7/6_inlining_2019_bright_victories_and_hidden_defeats.pdf)\n4. [Five things that make Go fast - Dave Cheney](https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast)\n5. [Mid-stack inlining in the Go compiler - David Lazar](/7/7_talk_Mid-stack_inlining_in_the_Go_compiler.pdf)\n","slug":"7-go-compiler-func-inlining"},{"data":{"title":"Go RPCs (Remote Procedure Calls)","date":"2021-05-28T11:04:32+05:30","draft":false,"tags":["golang"]},"content":"\n# Go RPCs (Remote Procedure Calls)\n\n## Introduction\n\nGo's `rpc` package enables communication across multiple machines, sort of like inter-process communication via funtion/method/procedure calls.\n\nAs the Go documentation puts it:\n\u003e Package `rpc` provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object.\n\nThe object that is registered with the `rpc` server can be either primitive/builtin data types (`int`, `string` etc.) or user-defined ones (such as `struct`s). I would usually prefer a `struct`.\n\nUnder the hood, by default, Go uses `gob` for serializing and deserializing the remote procedure calls. This is configurable, that is, you can plug-in `JSON` or other custom codecs.\n\n## Prerequisites\n\nThe methods which define actions on the registered object must adhere to a specific function signature. The methods,\n- and its type(s) must be exported (uppercased)\n- have two arguments, both exported (or builtin) types.\n- their second argument is a pointer.\n- must have one return type, `error`.\n\nEssentially the method signature looks like the following:\n```go\nfunc (t *T) MethodName(argType T1, replyType *T2) error\n```\n\n## Implementation\n\nLet's look at a dummy blog server and a client interacting with each other via `rpc`.\n### a. Types\n\nIt's a good idea to wrap the object, along with the methods and types, into a package of its own. This makes it easier for both the server and client implementations to agree on common type definitions.\n\nIn the following code, `Blog` will be registered with the `rpc` server.\n```go\ntype Blog struct {\n\tposts      map[int]Post\n\tlastPostID int\n\tsync.Mutex\n}\n\ntype Post struct {\n\tID    int\n\tTitle string\n\tBody  string\n}\n\n// NewBlog is required because, even though Blog is exported its fields are not.\n// The fields are internal to the package.\nfunc NewBlog() *Blog {\n\treturn \u0026Blog{\n\t\tposts: make(map[int]Post),\n\t}\n}\n```\nThe function `NewBlog() *Blog` is necessary since we aren't exporting its fields: `posts` and `lastPostID`.\n\n### b. Methods\n`Blog` will have two methods: `AddPost` and `GetPostByID`. Notice the function signature.\n```go\nfunc (b *Blog) AddPost(payload, reply *Post) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tif payload.Title == \"\" || payload.Body == \"\" {\n\t\treturn errors.New(\"Title and Body must not be empty\")\n\t}\n\n\tb.lastPostID++\n\n\t*reply = Post{ID: b.lastPostID, Title: payload.Title, Body: payload.Body}\n\tb.posts[reply.ID] = *reply\n\n\treturn nil\n}\n\nfunc (b *Blog) GetPostByID(payload int, reply *Post) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\t*reply = b.posts[payload]\n\n\treturn nil\n}\n```\n\nEach method takes two arguments, `payload` and `reply` (you can name them anything). It receives the input from the client in the first parameter. The second argument (a pointer) is used for sending a response back to the client.\n\n### c. Server\nThe server implementation is fairly simple:\n```go\n// Fetch an instance of the object\nblog := types.NewBlog()\n\nrpc.Register(blog) // Register the instance with the rpc\nrpc.HandleHTTP() // Configure the rpc to serve over HTTP\n\nerr := http.ListenAndServe(\":3000\", nil)\nif err != nil {\n\tlog.Fatalln(\"Error starting the RPC server\", err)\n}\n```\n\n### d. Client\n\nDial the server using `rpc.DialHTTP`:\n```go\nclient, err := rpc.DialHTTP(\"tcp\", \":3000\")\nif err != nil {\n\tlog.Fatalln(\"Error creating the RPC client\", err)\n}\n```\n\nAnd make the remote procedure calls using `client.Call`. It takes three arguments:\n1. The method name of the form: `\u003cT\u003e.\u003cMethodName\u003e`\n2. Input params\n3. A pointer to receive the response from the server\n```go\n// Create a post\nvar post types.Post\n\n// Create posts\nerr = client.Call(\"Blog.AddPost\", \u0026types.Post{Title: \"post 1\", Body: \"Hello, world!\"}, \u0026post)\nif err != nil {\n\tlog.Fatalln(\"Error creating post\", err)\n}\nlog.Printf(\"[AddPost] ID: %d | Title: %s | Body: %s\\n\", post.ID, post.Title, post.Body)\n\n// Fetch a post by ID\nerr = client.Call(\"Blog.GetPostByID\", 3, \u0026post)\nif err != nil {\n\tlog.Fatalln(\"Error creating post\", err)\n}\nlog.Printf(\"[GetPostByID] ID: %d | Title: %s | Body: %s\\n\", post.ID, post.Title, post.Body)\n```\n\nThe entire code can be found on [Github](https://github.com/bensooraj/blog-code-resource-repo/tree/main/borneo).\n\n## Some thoughts\n\nIn our implementation, the initial handshake between the `rpc` client and server are negotiated over HTTP. Thereafter, the HTTP server acts like a proxy or a conduit between the two, a concept known as [HTTP tunneling](https://en.wikipedia.org/wiki/HTTP_tunnel). I believe this can be customized.\n\nIt can be difficult to standardize (to follow common semantics) RPC implementations. This gap is what projects like `gRPC`, `dRPC` etc. attepmt to solve.\n\nIt should be obvious by now that you can register only one object with a given name with the `rpc` server.\n\nFurther reading:\n1. [godoc: Package `rpc`](https://golang.org/pkg/net/rpc/)\n2. [gRPC: A high performance, open source universal RPC framework](https://grpc.io/)\n3. [dRPC: A lightweight, drop-in replacement for gRPC](https://github.com/storj/drpc)\n\n---\n\nNote: _This article is not an in-depth tutorial or treatment of Golang's syntax, semantics, design or implementation, but a journal of my learnings._","slug":"6-go-rpc"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"hKGhU_jM7L7EOfUq9S-yp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>