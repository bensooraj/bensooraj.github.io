<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css"/><meta name="viewport" content="width=device-width"/><meta charSet="utf-8"/><title>Ben Sooraj - A journal of my learnings</title><meta name="keywords" content="golang, nodejs, mysql, docker, kubernetes, Ben Sooraj"/><meta name="next-head-count" content="4"/><link rel="preload" href="./_next/static/css/8ffa8c5c9f5551ae.css" as="style"/><link rel="stylesheet" href="./_next/static/css/8ffa8c5c9f5551ae.css" data-n-g=""/><link rel="preload" href="./_next/static/css/d0b847fa47fa8a5b.css" as="style"/><link rel="stylesheet" href="./_next/static/css/d0b847fa47fa8a5b.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="./_next/static/chunks/webpack-ed47cc4bbff8e103.js" defer=""></script><script src="./_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="./_next/static/chunks/main-7e73d61bce33e887.js" defer=""></script><script src="./_next/static/chunks/pages/_app-e6ebfa373a417a20.js" defer=""></script><script src="./_next/static/chunks/pages/index-5d214e47b0099a81.js" defer=""></script><script src="./_next/static/l-8ZIc7PmIhZlDg7sXrMO/_buildManifest.js" defer=""></script><script src="./_next/static/l-8ZIc7PmIhZlDg7sXrMO/_ssgManifest.js" defer=""></script><script src="./_next/static/l-8ZIc7PmIhZlDg7sXrMO/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><header class="Header_header__VYZ3G"><div class="max-width-container"><h2><a href="/">Ben Sooraj</a></h2><ul><li><a href="/about">About</a></li><li><a href="/blog">Blog</a></li></ul></div></header><main class="max-width-container main"><div><img src="/1597573125669.jpeg" alt="ben sooraj avatar" width="150" height="150" class="Home_img__Xgkmt"/><p>Hi üëãüèº, I&#x27;m Ben, a software engineer, a husband, a father and a voracious learner.</p></div><div class="Home_articleList__RW0kf"><h2 style="text-align:left;float:left">Latest Posts</h2><h4 style="text-align:right;float:right"><a href="/blog">Read all posts</a></h4><hr style="clear:both"/><div class="Home_postItem__bXXHD"><h3 style="text-align:left;float:left;padding-right:1em;margin-top:10px;margin-bottom:5px">18.07.2023</h3><h3 style="text-align:left;float:left;margin-top:10px;margin-bottom:5px"><a href="/blog/7-go-compiler-func-inlining">Function Inlining in Golang</a></h3><br style="clear:both"/></div><div class="Home_postItem__bXXHD"><h3 style="text-align:left;float:left;padding-right:1em;margin-top:10px;margin-bottom:5px">28.04.2021</h3><h3 style="text-align:left;float:left;margin-top:10px;margin-bottom:5px"><a href="/blog/6-go-rpc">Go RPCs (Remote Procedure Calls)</a></h3><br style="clear:both"/></div><div class="Home_postItem__bXXHD"><h3 style="text-align:left;float:left;padding-right:1em;margin-top:10px;margin-bottom:5px">01.08.2020</h3><h3 style="text-align:left;float:left;margin-top:10px;margin-bottom:5px"><a href="/blog/4-empty-interface-and-struct">The empty interface and the empty struct in golang</a></h3><br style="clear:both"/></div></div></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"posts":[{"data":{"title":"Function Inlining in Golang","date":"2023-08-18T10:00:00+05:30","draft":true,"tags":["golang"]},"content":"\nimport MDImage from '../../../components/MDImage.js';\n\n# Function Inlining in Golang\n\n## What is Inlining?\n\nInlining is a form of compiler optimisation where the compiler replaces a function call with the function's body to reduce the overhead of the function call. The following diagram crudely shows what this process looks like.\n\n\u003cMDImage src=\"/7/0_func_inlining.png\" alt=\"Function inlining illustration\" /\u003e\n\nLet's take an example Go program.\n\n```go\n// main.go\npackage main\n\nfunc main() {\n\tvar a int = 10\n\tvar b int = 20\n\t\n\tc := sum(a, b)\n\tprint(c)\n\t\n\td := difference(b, a)\n\tprint(d)\n}\n\nfunc sum(a int, b int) int {\n\treturn a + b\n}\n\nfunc difference(a int, b int) int {\n\treturn a - b\n}\n```\n\nBuild the above program using the following command,\n```sh\nGOOS=darwin GOARCH=amd64 go build -o expinline_darwin_amd64\n```\n\nTo understand inlining in practice, we will have to look at the assembly code generated by the above command and for that, we will have to disassemble the binary `expinline_darwin_amd64`.\n\nBefore we do that, let's look at the symbols (I am looking for the function names here),\n```sh\n$ objdump --syms expinline_darwin_amd64 | grep -E '_main.main|sum|difference'        \n0000000001057600 l     F __TEXT,__text _main.main\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n```\nYou will see no symbols for the functions `sum` and `difference`. To understand why this is the case, let's dig deeper into the assembly code,\n```sh\n$ objdump expinline_darwin_amd64 --disassemble-symbols=_main.main\n```\n\u003cMDImage src=\"/7/1_opt_and_inline_asm.jpeg\" alt=\"\" /\u003e\n\nSurprisingly, I see no function calls (`callq`) to `sum` or `difference`. It looks as if the compiler was smart enough to reduce the whole program to calling the print function on two absolute constants `30` (`a`+`b`) and `10` (`b`-`a`) denoted by `movl $30, %eax` and `movl $10, %eax` respectively, before the call to `print`.\n\nLet's turn off this compiler optimisation to preserve calculation logic and reevaluate the results.\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-N' -o expinline_darwin_amd64_no_op\n```\n\nAnd examine the `_main.main` symbol again,\n```sh\n$ objdump expinline_darwin_amd64_no_op --disassemble-symbols=_main.main\n```\n\u003cMDImage src=\"/7/2_no_opt_asm.jpeg\" alt=\"\" /\u003e\n\nNow you can observe that there is addition logic between the offsets `105762a` and `105763c`  and subtraction logic between the offsets `1057665` and `105767c`. Again, there are no function calls (`callq`) to `sum` or `difference`, indicating that they have been inlined into the caller `main()`.\n\nAlong with turning off the optimisation, `inlining` can also be turned off.\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-N -l' -o expinline_darwin_amd64_no_op_no_inline\n```\nIf you examine the symbols now, you can see the missing functions as well:\n```sh\n$ objdump --syms expinline_darwin_amd64_no_op_no_inline | grep -E '_main.main|sum|difference'\n00000000010576e0 l     F __TEXT,__text _main.difference\n0000000001057600 l     F __TEXT,__text _main.main\n00000000010576a0 l     F __TEXT,__text _main.sum\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n```\nAnd here's the disassembled code,\n\u003cMDImage src=\"/7/3_no_opt_no_inline_asm.jpeg\" alt=\"\" /\u003e\n\n## Why inline?\n\n### Improves performance by minimising the function call overheads\nThese overheads include stack manipulation, CPU register loading/unloading, branching, handling return values, etc.\n\nLet's perform a quick benchmark test to gauge the gain in performance. The following bench function calls the `sum` and `difference` functions,\n```go\n// main_bench_test.go\npackage main\n\nimport \"testing\"\n\nvar Result int\n\nfunc BenchmarkSpecialBinomialProduct(b *testing.B) {\n\tvar r int\n\tfor i := 0; i \u003c b.N; i++ {\n\t\tr = sum(i, i+7) * difference(i+7, i)\n\t}\n\tResult = r\n}\n```\n\nRun it with all the default optimisations turned on,\n```sh\n$ go test -run='^$' -bench=. -benchmem -benchtime=10s -count=10 \u003e bench_with_inlining.txt\n```\n\nNow add the compiler directive `//go:noinline` just above the function definitions of `sum` and `difference` and rerun the bench,\n```sh\n$ go test -run='^$' -bench=. -benchmem -benchtime=10s -count=10 \u003e bench_with_no_inlining.txt\n```\n\nFinally, compare the results from the benchmark above,\n```sh\n$ benchstat {bench_with_no_inlining,bench_with_inlining}.txt\n```\n\u003cMDImage src=\"/7/4_benchstat.png\" alt=\"\" /\u003e\n\nAlbeit a contrived example, you can see a performance improvement of ~78%.\n\nTwo things to note about inlining.\n* It is a trade-off between space (increased binary size) and time (performance). This is because the function's body is copied to everywhere it is called.\n* It yields diminishing returns as the functions get larger or more complex because the call overhead to these functions becomes relatively negligible.\n\n### Augments escape analysis\n\nEscape analysis is a compiler optimisation technique that determines if a value can be on the stack frame for the function constructing it or if the value must ‚Äúescape‚Äù to the heap.\n\nLet's consider the following example,\n``` go\n// escape/main.go\npackage main\n\ntype Point struct {\n\tx, y int\n}\n\nfunc NewPoint(x, y int) *Point {\n\treturn \u0026Point{x, y} // 8:9\n}\n\nfunc main() {\n\tp1 := NewPoint(10, 20) // 12:16\n\tp2 := NewPoint(30, 40) // 13:16\n\t\n\tprint(p1.x, p2.y)\n}\n```\n\nBuild the above program with the `-m` compiler flag to print optimisation decisions,\n```sh\n$ go build -gcflags='-m=1' escape/main.go         \n# command-line-arguments\nescape/main.go:7:6: can inline NewPoint\nescape/main.go:11:6: can inline main\nescape/main.go:12:16: inlining call to NewPoint\nescape/main.go:13:16: inlining call to NewPoint\nescape/main.go:8:9: \u0026Point{...} escapes to heap\nescape/main.go:12:16: \u0026Point{...} does not escape\nescape/main.go:13:16: \u0026Point{...} does not escape\n```\n\nSince `NewPoint` is expanded inside the `main` function, the lifetimes of `Point{10, 20}` and `Point{30, 40}` are bound within the `main`'s scope. \n\nNow build with inlining turned off,\n```sh\n$ go build -gcflags='-m=1 -l' escape/main.go\n# command-line-arguments\nescape/main.go:8:9: \u0026Point{...} escapes to heap\n```\n\nEach call to `NewPoint(..)` will result in a `Point` object allocated to the heap memory.\n\n## How does the compiler do that?\n\nGo's compiler uses a combination of budget and cost to determine whether to inline a function. Every function has a cost compared against a budget (threshold). \n\nA function's cost is calculated using the complexity of the statements within the function body (one unit per node in the AST). And the budget changes from one release (40 in Go 1.6 | [src/cmd/compile/internal/gc/inl.go](https://github.com/golang/go/blob/7bc40ffb05d8813bf9b41a331b45d37216f9e747/src/cmd/compile/internal/gc/inl.go#L14)) to another (80 | [src/cmd/compile/internal/inline/inl.go](https://github.com/golang/go/blob/4be921d888d3a68c51e38d4c615a4438c7b2cb30/src/cmd/compile/internal/inline/inl.go#L47)).\n\nLet's take the following example,\n\u003cMDImage src=\"/7/5_cost_budget_midstack.jpeg\" alt=\"\" /\u003e\n\nFigures `a`, `b` and `c` represent the same program, each with slight modifications (green highlight) to demonstrate cost allocation and mid-stack inlining.\n\nLet's build the program in Figure `a` (output condensed for relevance),\n```sh\n$ GOOS=darwin GOARCH=amd64 go build -gcflags='-m=2' midstack/main.go                      \n# command-line-arguments\nmidstack/main.go:30:6: can inline Sum with cost 4 as: func(int, int) int { return a + b }\nmidstack/main.go:23:6: can inline MidPoint with cost 28 as: func(Point, Point) Point { return Point{...} }\nmidstack/main.go:25:9: inlining call to Sum\nmidstack/main.go:26:9: inlining call to Sum\nmidstack/main.go:18:6: cannot inline PrintPoint: function too complex: cost 89 exceeds budget 80\nmidstack/main.go:20:13: inlining call to fmt.Println\nmidstack/main.go:10:6: cannot inline main: function too complex: cost 114 exceeds budget 80\nmidstack/main.go:13:26: inlining call to MidPoint\nmidstack/main.go:13:26: inlining call to Sum\nmidstack/main.go:13:26: inlining call to Sum\n```\n\nYou can see that each function has a cost assigned to it, which is compared against the budget (`80`) to decide whether the function can be inlined. The functions `MidPoint` (cost: `28`) and `Sum` (cost: `4`) are inline-able, whereas `PrintPoint` (cost: `89`) and `main` (cost: `114`) are not.\n\nI will also use this example to showcase the two forms of inlining,\n1. Leaf inlining\n\t- Earlier, only functions that did not call other functions (bottom of the call stack) were eligible for inlining. Once a leaf function is inlined, the resulting code can be inlined into its caller, a recursive process.\n\t- For example, `Sum` (a leaf function) gets inlined into `MidPoint`. Next, `MidPoint` (a leaf function now) gets inlined into `main`.\n2. Mid-stack inlining\n\t- Now, non-leaf functions are also eligible for inlining.\n\t- For example, in Figure `c`, the function `Sum` is marked with the directive `//go:noinline`, making it non-eligible for inlining. Even though `MidPoint` calls `Sum`, it is allocated a cost of `76`, making it eligible for inlining.\n\n## References\n1. [Inlining optimisations in Go - Dave Cheney](https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-5-4053)\n2. [Mid-stack inlining in Go - Dave Cheney](https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go#easy-footnote-bottom-1-4076)\n3. [Inlining - bright victories and hidden defeats](/7/6_inlining_2019_bright_victories_and_hidden_defeats.pdf)\n4. [Five things that make Go fast - Dave Cheney](https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast)\n5. [Mid-stack inlining in the Go compiler - David Lazar](/7/7_talk_Mid-stack_inlining_in_the_Go_compiler.pdf)\n","slug":"7-go-compiler-func-inlining"},{"data":{"title":"Go RPCs (Remote Procedure Calls)","date":"2021-05-28T11:04:32+05:30","draft":false,"tags":["golang"]},"content":"\n# Go RPCs (Remote Procedure Calls)\n\n## Introduction\n\nGo's `rpc` package enables communication across multiple machines, sort of like inter-process communication via funtion/method/procedure calls.\n\nAs the Go documentation puts it:\n\u003e Package `rpc` provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object.\n\nThe object that is registered with the `rpc` server can be either primitive/builtin data types (`int`, `string` etc.) or user-defined ones (such as `struct`s). I would usually prefer a `struct`.\n\nUnder the hood, by default, Go uses `gob` for serializing and deserializing the remote procedure calls. This is configurable, that is, you can plug-in `JSON` or other custom codecs.\n\n## Prerequisites\n\nThe methods which define actions on the registered object must adhere to a specific function signature. The methods,\n- and its type(s) must be exported (uppercased)\n- have two arguments, both exported (or builtin) types.\n- their second argument is a pointer.\n- must have one return type, `error`.\n\nEssentially the method signature looks like the following:\n```go\nfunc (t *T) MethodName(argType T1, replyType *T2) error\n```\n\n## Implementation\n\nLet's look at a dummy blog server and a client interacting with each other via `rpc`.\n### a. Types\n\nIt's a good idea to wrap the object, along with the methods and types, into a package of its own. This makes it easier for both the server and client implementations to agree on common type definitions.\n\nIn the following code, `Blog` will be registered with the `rpc` server.\n```go\ntype Blog struct {\n\tposts      map[int]Post\n\tlastPostID int\n\tsync.Mutex\n}\n\ntype Post struct {\n\tID    int\n\tTitle string\n\tBody  string\n}\n\n// NewBlog is required because, even though Blog is exported its fields are not.\n// The fields are internal to the package.\nfunc NewBlog() *Blog {\n\treturn \u0026Blog{\n\t\tposts: make(map[int]Post),\n\t}\n}\n```\nThe function `NewBlog() *Blog` is necessary since we aren't exporting its fields: `posts` and `lastPostID`.\n\n### b. Methods\n`Blog` will have two methods: `AddPost` and `GetPostByID`. Notice the function signature.\n```go\nfunc (b *Blog) AddPost(payload, reply *Post) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\tif payload.Title == \"\" || payload.Body == \"\" {\n\t\treturn errors.New(\"Title and Body must not be empty\")\n\t}\n\n\tb.lastPostID++\n\n\t*reply = Post{ID: b.lastPostID, Title: payload.Title, Body: payload.Body}\n\tb.posts[reply.ID] = *reply\n\n\treturn nil\n}\n\nfunc (b *Blog) GetPostByID(payload int, reply *Post) error {\n\tb.Lock()\n\tdefer b.Unlock()\n\n\t*reply = b.posts[payload]\n\n\treturn nil\n}\n```\n\nEach method takes two arguments, `payload` and `reply` (you can name them anything). It receives the input from the client in the first parameter. The second argument (a pointer) is used for sending a response back to the client.\n\n### c. Server\nThe server implementation is fairly simple:\n```go\n// Fetch an instance of the object\nblog := types.NewBlog()\n\nrpc.Register(blog) // Register the instance with the rpc\nrpc.HandleHTTP() // Configure the rpc to serve over HTTP\n\nerr := http.ListenAndServe(\":3000\", nil)\nif err != nil {\n\tlog.Fatalln(\"Error starting the RPC server\", err)\n}\n```\n\n### d. Client\n\nDial the server using `rpc.DialHTTP`:\n```go\nclient, err := rpc.DialHTTP(\"tcp\", \":3000\")\nif err != nil {\n\tlog.Fatalln(\"Error creating the RPC client\", err)\n}\n```\n\nAnd make the remote procedure calls using `client.Call`. It takes three arguments:\n1. The method name of the form: `\u003cT\u003e.\u003cMethodName\u003e`\n2. Input params\n3. A pointer to receive the response from the server\n```go\n// Create a post\nvar post types.Post\n\n// Create posts\nerr = client.Call(\"Blog.AddPost\", \u0026types.Post{Title: \"post 1\", Body: \"Hello, world!\"}, \u0026post)\nif err != nil {\n\tlog.Fatalln(\"Error creating post\", err)\n}\nlog.Printf(\"[AddPost] ID: %d | Title: %s | Body: %s\\n\", post.ID, post.Title, post.Body)\n\n// Fetch a post by ID\nerr = client.Call(\"Blog.GetPostByID\", 3, \u0026post)\nif err != nil {\n\tlog.Fatalln(\"Error creating post\", err)\n}\nlog.Printf(\"[GetPostByID] ID: %d | Title: %s | Body: %s\\n\", post.ID, post.Title, post.Body)\n```\n\nThe entire code can be found on [Github](https://github.com/bensooraj/blog-code-resource-repo/tree/main/borneo).\n\n## Some thoughts\n\nIn our implementation, the initial handshake between the `rpc` client and server are negotiated over HTTP. Thereafter, the HTTP server acts like a proxy or a conduit between the two, a concept known as [HTTP tunneling](https://en.wikipedia.org/wiki/HTTP_tunnel). I believe this can be customized.\n\nIt can be difficult to standardize (to follow common semantics) RPC implementations. This gap is what projects like `gRPC`, `dRPC` etc. attepmt to solve.\n\nIt should be obvious by now that you can register only one object with a given name with the `rpc` server.\n\nFurther reading:\n1. [godoc: Package `rpc`](https://golang.org/pkg/net/rpc/)\n2. [gRPC: A high performance, open source universal RPC framework](https://grpc.io/)\n3. [dRPC: A lightweight, drop-in replacement for gRPC](https://github.com/storj/drpc)\n\n---\n\nNote: _This article is not an in-depth tutorial or treatment of Golang's syntax, semantics, design or implementation, but a journal of my learnings._","slug":"6-go-rpc"},{"data":{"title":"The empty interface and the empty struct in golang","date":"2020-09-01T17:04:32+05:30","draft":false,"tags":["golang"]},"content":"\n# The empty interface and the empty struct in golang\n\nAn `interface` is a collection or set of method declarations. A data type implements or satisfies an `interface` if it at least defines the methods declared by the `interface`.\n\n## Empty interface\n\nAn empty interface `interface{}` has zero methods. So, in essence, any data type implements or satisfies an empty interface. Let's take the following example:\n\n```go\ntype Container []interface{}\n\nfunc (c *Container) Put(elem interface{}) {\n    *c = append(*c, elem)\n    switch elem.(type) {\n    case int:\n        fmt.Println(\"Put \", elem, \" of type int\")\n    case string:\n        fmt.Println(\"Put \", elem, \" of type string\")\n    default:\n        fmt.Println(\"Put \", elem, \" of type unknown\")\n    }\n}\n\nfunc (c *Container) Pop() interface{} {\n    elem := (*c)[0]\n    *c = (*c)[1:]\n    return elem\n}\n\nfunc main() {\n    allContainer := \u0026Container{}\n\n    allContainer.Put(\"Hello\")\n    allContainer.Put(213)\n    allContainer.Put(123.321)\n\n    fmt.Printf(\"allContainer: %+v\\n\\n\", allContainer)\n}\n```\n\nOutput:\n\n```sh\n$ go run main.go\nPut  Hello  of type string\nPut  213  of type int\nPut  123.321  of type unknown\nallContainer: \u0026[Hello 213 123.321]\n```\n\nIn the above example, the data type `Container` is a slice of empty interfaces with two methods defined on it, `Put()` and `Pop()`. It loosely resembles a _First In, Last Out_ stack.\n\nThe `Put()` method takes an `interface{}` as the input argument and appends it to the slice of `interface{}`s. This means that it can accept a string, an integer, a float or any other simple and composite data type as its input argument. You can access the underlying type of `elem`, an `interface{}`, using `elem.(type)`.\n\nThis approach does have its disadvantages though. One being that you should implement type assertions, checks or type specific logics to avoid any surprises during runtime.\n\n## Empty struct\n\nTo quote the Golang spec:\n\n\u003e A struct is a sequence of named elements, called fields, each of which has a name and a type.\n\nLet's take an example\n\n```go\n// A struct with 5 fields.\nstruct {\n    x, y int\n    u float32\n    A *[]int\n    F func()\n}\n```\n\nAn empty struct is a struct data type with zero fields:\n\n```go\n// Named type\ntype EmptyStruct struct{}\n\n// Variable declaration\nvar es struct{}\n\n// Or use it directly!\nstruct{}{}\n```\n\nThe size or width of a `struct` is defined as the sum of its constituent types. An empty `struct`, since it has no fields within it, has a size or width of zero. Zero bytes!\n\nJust like regular structs you can define methods on empty structs as well. Sort of like a zero sized container for methods:\n\n```go\ntype EmptyStruct struct{}\n\nfunc (es *EmptyStruct) WhoAmI() {\n    fmt.Println(\"I am an empty struct!\")\n}\n```\n\nEmpty structs find its best use case in channel signalling. Many a mere mortals such as me have used booleans or integers to notify an event over a channel.\n\nThe following example prints the current time at every 500 milliseconds and times out after 3 seconds,\n\n```go\nfunc printFor3Seconds(doneChannel chan struct{}) {\n    ticker := time.NewTicker(500 * time.Millisecond)\n    timeout := time.After(3 * time.Second)\n\n    for {\n        select {\n        case t := \u003c-ticker.C:\n            fmt.Printf(\"Tik tik: %v\\n\", t)\n        case \u003c-timeout:\n            fmt.Printf(\"Timeout at: %v\\n\", time.Now())\n            doneChannel \u003c- struct{}{}\n            return\n        }\n    }\n}\n\nfunc main() {\n    doneChannel := make(chan struct{}, 1)\n\n    go printFor3Seconds(doneChannel)\n\n    \u003c-doneChannel\n}\n\n// Output\n// $ go run 1.go\n// Tik tik: 2020-09-16 08:25:36.750631 +0530 IST m=+0.501680080\n// Tik tik: 2020-09-16 08:25:37.250303 +0530 IST m=+1.001337269\n// Tik tik: 2020-09-16 08:25:37.750696 +0530 IST m=+1.501714888\n// Tik tik: 2020-09-16 08:25:38.253708 +0530 IST m=+2.004711715\n// Tik tik: 2020-09-16 08:25:38.752804 +0530 IST m=+2.503793180\n// Tik tik: 2020-09-16 08:25:39.251941 +0530 IST m=+3.002914584\n// Timeout at: 2020-09-16 08:25:39.251999 +0530 IST m=+3.002972846\n```\n\nInstead of `doneChannel \u003c- 0` or `doneChannel \u003c- true`, I am using `doneChannel \u003c- struct{}{}` for channel signalling. Using booleans or integers for channel signalling involves memory allocation, copying over the element etc.\n\nWe can use empty structs for simulating sets as well,\n\n```go\nintSet := make(map[int]struct{})\nempty := struct{}{}\n\n// We are setting empty as the value for 1, because the\n// value is meaningless\nintSet[1] = empty\nif _, ok := intSet[1]; ok {\n    fmt.Println(\"1 is in the set\")\n}\n\n// 2 is not one of intSet's keys\nif _, ok := intSet[2]; !ok {\n    fmt.Println(\"2 is not in the set\")\n}\n```\n\n## Resources:\n\n1. [The Go Programming Language Specification](https://golang.org/ref/spec#Struct_types)\n2. [The empty struct - Dave Cheney](https://dave.cheney.net/2014/03/25/the-empty-struct)\n\n---\n\nNote: _This article is not an in-depth tutorial or treatment of Golang's syntax, semantics, design or implementation, but a journal of my learnings._","slug":"4-empty-interface-and-struct"}]},"__N_SSG":true},"page":"/","query":{},"buildId":"l-8ZIc7PmIhZlDg7sXrMO","assetPrefix":".","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>