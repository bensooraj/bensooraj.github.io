(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[540],{1883:function(n,e,s){(window.__NEXT_P=window.__NEXT_P||[]).push(["/blog/7-go-compiler-func-inlining",function(){return s(4834)}])},1290:function(n,e,s){"use strict";var i=s(5893),l=s(5711),a=s.n(l),c=function(n){var e=n.src,s=n.alt,l=n.width,c=n.height;return(0,i.jsx)("img",{className:a().carousel,src:e,alt:s,width:l,height:c})};e.Z=c,c.defaultProps={width:"100%",height:"100%"}},4834:function(n,e,s){"use strict";s.r(e);var i=s(5893),l=s(1151),a=s(1290);function c(n){var e=Object.assign({h1:"h1",h2:"h2",p:"p",pre:"pre",code:"code",span:"span",h3:"h3",ul:"ul",li:"li",a:"a",ol:"ol"},(0,l.ah)(),n.components);return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.h1,{children:"Function Inlining in Golang"}),"\n",(0,i.jsx)(e.h2,{children:"What is Inlining?"}),"\n",(0,i.jsx)(e.p,{children:"Inlining is a form of compiler optimisation where the compiler replaces a function call with the function's body to reduce the overhead of the function call. The following diagram crudely shows what this process looks like."}),"\n",(0,i.jsx)(a.Z,{src:"/7/0_func_inlining.png",alt:"Function inlining illustration"}),"\n",(0,i.jsx)(e.p,{children:"Let's take an example Go program."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-go",children:[(0,i.jsx)(e.span,{className:"hljs-comment",children:"// main.go"}),"\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"package"})," main\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"main"}),(0,i.jsx)(e.span,{className:"hljs-params",children:"()"})]})," {\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"var"})," a ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"})," = ",(0,i.jsx)(e.span,{className:"hljs-number",children:"10"}),"\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"var"})," b ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"})," = ",(0,i.jsx)(e.span,{className:"hljs-number",children:"20"}),"\n\t\n\tc := sum(a, b)\n\t",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"print"}),"(c)\n\t\n\td := difference(b, a)\n\t",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"print"}),"(d)\n}\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"sum"}),(0,i.jsxs)(e.span,{className:"hljs-params",children:["(a ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),", b ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),")"]})]})," ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"})," {\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"return"})," a + b\n}\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"difference"}),(0,i.jsxs)(e.span,{className:"hljs-params",children:["(a ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),", b ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),")"]})]})," ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"})," {\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"return"})," a - b\n}\n"]})}),"\n",(0,i.jsx)(e.p,{children:"Build the above program using the following command,"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"hljs language-sh",children:"GOOS=darwin GOARCH=amd64 go build -o expinline_darwin_amd64\n"})}),"\n",(0,i.jsxs)(e.p,{children:["To understand inlining in practice, we will have to look at the assembly code generated by the above command and for that, we will have to disassemble the binary ",(0,i.jsx)(e.code,{children:"expinline_darwin_amd64"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"Before we do that, let's look at the symbols (I am looking for the function names here),"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ objdump --syms expinline_darwin_amd64 | grep -E ",(0,i.jsx)(e.span,{className:"hljs-string",children:"'_main.main|sum|difference'"}),"        \n0000000001057600 l     F __TEXT,__text _main.main\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["You will see no symbols for the functions ",(0,i.jsx)(e.code,{children:"sum"})," and ",(0,i.jsx)(e.code,{children:"difference"}),". To understand why this is the case, let's dig deeper into the assembly code,"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"hljs language-sh",children:"$ objdump expinline_darwin_amd64 --disassemble-symbols=_main.main\n"})}),"\n",(0,i.jsx)(a.Z,{src:"/7/1_opt_and_inline_asm.jpeg",alt:""}),"\n",(0,i.jsxs)(e.p,{children:["Surprisingly, I see no function calls (",(0,i.jsx)(e.code,{children:"callq"}),") to ",(0,i.jsx)(e.code,{children:"sum"})," or ",(0,i.jsx)(e.code,{children:"difference"}),". It looks as if the compiler was smart enough to reduce the whole program to calling the print function on two absolute constants ",(0,i.jsx)(e.code,{children:"30"})," (",(0,i.jsx)(e.code,{children:"a"}),"+",(0,i.jsx)(e.code,{children:"b"}),") and ",(0,i.jsx)(e.code,{children:"10"})," (",(0,i.jsx)(e.code,{children:"b"}),"-",(0,i.jsx)(e.code,{children:"a"}),") denoted by ",(0,i.jsx)(e.code,{children:"movl $30, %eax"})," and ",(0,i.jsx)(e.code,{children:"movl $10, %eax"})," respectively, before the call to ",(0,i.jsx)(e.code,{children:"print"}),"."]}),"\n",(0,i.jsx)(e.p,{children:"Let's turn off this compiler optimisation to preserve calculation logic and reevaluate the results."}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ GOOS=darwin GOARCH=amd64 go build -gcflags=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'-N'"})," -o expinline_darwin_amd64_no_op\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["And examine the ",(0,i.jsx)(e.code,{children:"_main.main"})," symbol again,"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"hljs language-sh",children:"$ objdump expinline_darwin_amd64_no_op --disassemble-symbols=_main.main\n"})}),"\n",(0,i.jsx)(a.Z,{src:"/7/2_no_opt_asm.jpeg",alt:""}),"\n",(0,i.jsxs)(e.p,{children:["Now you can observe that there is addition logic between the offsets ",(0,i.jsx)(e.code,{children:"105762a"})," and ",(0,i.jsx)(e.code,{children:"105763c"}),"  and subtraction logic between the offsets ",(0,i.jsx)(e.code,{children:"1057665"})," and ",(0,i.jsx)(e.code,{children:"105767c"}),". Again, there are no function calls (",(0,i.jsx)(e.code,{children:"callq"}),") to ",(0,i.jsx)(e.code,{children:"sum"})," or ",(0,i.jsx)(e.code,{children:"difference"}),", indicating that they have been inlined into the caller ",(0,i.jsx)(e.code,{children:"main()"}),"."]}),"\n",(0,i.jsxs)(e.p,{children:["Along with turning off the optimisation, ",(0,i.jsx)(e.code,{children:"inlining"})," can also be turned off."]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ GOOS=darwin GOARCH=amd64 go build -gcflags=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'-N -l'"})," -o expinline_darwin_amd64_no_op_no_inline\n"]})}),"\n",(0,i.jsx)(e.p,{children:"If you examine the symbols now, you can see the missing functions as well:"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ objdump --syms expinline_darwin_amd64_no_op_no_inline | grep -E ",(0,i.jsx)(e.span,{className:"hljs-string",children:"'_main.main|sum|difference'"}),"\n00000000010576e0 l     F __TEXT,__text _main.difference\n0000000001057600 l     F __TEXT,__text _main.main\n00000000010576a0 l     F __TEXT,__text _main.",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"sum"}),"\n0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume\n0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize\n000000000102c9c0 l     F __TEXT,__text _runtime.resumeG\n"]})}),"\n",(0,i.jsx)(e.p,{children:"And here's the disassembled code,"}),"\n",(0,i.jsx)(a.Z,{src:"/7/3_no_opt_no_inline_asm.jpeg",alt:""}),"\n",(0,i.jsx)(e.h2,{children:"Why inline?"}),"\n",(0,i.jsx)(e.h3,{children:"Improves performance by minimising the function call overheads"}),"\n",(0,i.jsx)(e.p,{children:"These overheads include stack manipulation, CPU register loading/unloading, branching, handling return values, etc."}),"\n",(0,i.jsxs)(e.p,{children:["Let's perform a quick benchmark test to gauge the gain in performance. The following bench function calls the ",(0,i.jsx)(e.code,{children:"sum"})," and ",(0,i.jsx)(e.code,{children:"difference"})," functions,"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-go",children:[(0,i.jsx)(e.span,{className:"hljs-comment",children:"// main_bench_test.go"}),"\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"package"})," main\n\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"import"})," ",(0,i.jsx)(e.span,{className:"hljs-string",children:'"testing"'}),"\n\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"var"})," Result ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),"\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"BenchmarkSpecialBinomialProduct"}),(0,i.jsx)(e.span,{className:"hljs-params",children:"(b *testing.B)"})]})," {\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"var"})," r ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),"\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"for"})," i := ",(0,i.jsx)(e.span,{className:"hljs-number",children:"0"}),"; i < b.N; i++ {\n\t\tr = sum(i, i+",(0,i.jsx)(e.span,{className:"hljs-number",children:"7"}),") * difference(i+",(0,i.jsx)(e.span,{className:"hljs-number",children:"7"}),", i)\n\t}\n\tResult = r\n}\n"]})}),"\n",(0,i.jsx)(e.p,{children:"Run it with all the default optimisations turned on,"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ go ",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"test"})," -run=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'^$'"})," -bench=. -benchmem -benchtime=10s -count=10 > bench_with_inlining.txt\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["Now add the compiler directive ",(0,i.jsx)(e.code,{children:"//go:noinline"})," just above the function definitions of ",(0,i.jsx)(e.code,{children:"sum"})," and ",(0,i.jsx)(e.code,{children:"difference"})," and rerun the bench,"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ go ",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"test"})," -run=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'^$'"})," -bench=. -benchmem -benchtime=10s -count=10 > bench_with_no_inlining.txt\n"]})}),"\n",(0,i.jsx)(e.p,{children:"Finally, compare the results from the benchmark above,"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"hljs language-sh",children:"$ benchstat {bench_with_no_inlining,bench_with_inlining}.txt\n"})}),"\n",(0,i.jsx)(a.Z,{src:"/7/4_benchstat.png",alt:""}),"\n",(0,i.jsx)(e.p,{children:"Albeit a contrived example, you can see a performance improvement of ~78%."}),"\n",(0,i.jsx)(e.p,{children:"Two things to note about inlining."}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"It is a trade-off between space (increased binary size) and time (performance). This is because the function's body is copied to everywhere it is called."}),"\n",(0,i.jsx)(e.li,{children:"It yields diminishing returns as the functions get larger or more complex because the call overhead to these functions becomes relatively negligible."}),"\n"]}),"\n",(0,i.jsx)(e.h3,{children:"Augments escape analysis"}),"\n",(0,i.jsx)(e.p,{children:"Escape analysis is a compiler optimisation technique that determines if a value can be on the stack frame for the function constructing it or if the value must \u201cescape\u201d to the heap."}),"\n",(0,i.jsx)(e.p,{children:"Let's consider the following example,"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-go",children:[(0,i.jsx)(e.span,{className:"hljs-comment",children:"// escape/main.go"}),"\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"package"})," main\n\n",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"type"})," Point ",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"struct"})," {\n\tx, y ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),"\n}\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"NewPoint"}),(0,i.jsxs)(e.span,{className:"hljs-params",children:["(x, y ",(0,i.jsx)(e.span,{className:"hljs-type",children:"int"}),")"]})]})," *Point {\n\t",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"return"})," &Point{x, y} ",(0,i.jsx)(e.span,{className:"hljs-comment",children:"// 8:9"}),"\n}\n\n",(0,i.jsxs)(e.span,{className:"hljs-function",children:[(0,i.jsx)(e.span,{className:"hljs-keyword",children:"func"})," ",(0,i.jsx)(e.span,{className:"hljs-title",children:"main"}),(0,i.jsx)(e.span,{className:"hljs-params",children:"()"})]})," {\n\tp1 := NewPoint(",(0,i.jsx)(e.span,{className:"hljs-number",children:"10"}),", ",(0,i.jsx)(e.span,{className:"hljs-number",children:"20"}),") ",(0,i.jsx)(e.span,{className:"hljs-comment",children:"// 12:16"}),"\n\tp2 := NewPoint(",(0,i.jsx)(e.span,{className:"hljs-number",children:"30"}),", ",(0,i.jsx)(e.span,{className:"hljs-number",children:"40"}),") ",(0,i.jsx)(e.span,{className:"hljs-comment",children:"// 13:16"}),"\n\t\n\t",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"print"}),"(p1.x, p2.y)\n}\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["Build the above program with the ",(0,i.jsx)(e.code,{children:"-m"})," compiler flag to print optimisation decisions,"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ go build -gcflags=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'-m=1'"})," escape/main.go         \n",(0,i.jsx)(e.span,{className:"hljs-comment",children:"# command-line-arguments"}),"\nescape/main.go:7:6: can inline NewPoint\nescape/main.go:11:6: can inline main\nescape/main.go:12:16: inlining call to NewPoint\nescape/main.go:13:16: inlining call to NewPoint\nescape/main.go:8:9: &Point{...} escapes to heap\nescape/main.go:12:16: &Point{...} does not escape\nescape/main.go:13:16: &Point{...} does not escape\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["Since ",(0,i.jsx)(e.code,{children:"NewPoint"})," is expanded inside the ",(0,i.jsx)(e.code,{children:"main"})," function, the lifetimes of ",(0,i.jsx)(e.code,{children:"Point{10, 20}"})," and ",(0,i.jsx)(e.code,{children:"Point{30, 40}"})," are bound within the ",(0,i.jsx)(e.code,{children:"main"}),"'s scope."]}),"\n",(0,i.jsx)(e.p,{children:"Now build with inlining turned off,"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ go build -gcflags=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'-m=1 -l'"})," escape/main.go\n",(0,i.jsx)(e.span,{className:"hljs-comment",children:"# command-line-arguments"}),"\nescape/main.go:8:9: &Point{...} escapes to heap\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["Each call to ",(0,i.jsx)(e.code,{children:"NewPoint(..)"})," will result in a ",(0,i.jsx)(e.code,{children:"Point"})," object allocated to the heap memory."]}),"\n",(0,i.jsx)(e.h2,{children:"How does the compiler do that?"}),"\n",(0,i.jsx)(e.p,{children:"Go's compiler uses a combination of budget and cost to determine whether to inline a function. Every function has a cost compared against a budget (threshold)."}),"\n",(0,i.jsxs)(e.p,{children:["A function's cost is calculated using the complexity of the statements within the function body (one unit per node in the AST). And the budget changes from one release (40 in Go 1.6 | ",(0,i.jsx)(e.a,{href:"https://github.com/golang/go/blob/7bc40ffb05d8813bf9b41a331b45d37216f9e747/src/cmd/compile/internal/gc/inl.go#L14",children:"src/cmd/compile/internal/gc/inl.go"}),") to another (80 | ",(0,i.jsx)(e.a,{href:"https://github.com/golang/go/blob/4be921d888d3a68c51e38d4c615a4438c7b2cb30/src/cmd/compile/internal/inline/inl.go#L47",children:"src/cmd/compile/internal/inline/inl.go"}),")."]}),"\n",(0,i.jsx)(e.p,{children:"Let's take the following example,"}),"\n",(0,i.jsx)(a.Z,{src:"/7/5_cost_budget_midstack.jpeg",alt:""}),"\n",(0,i.jsxs)(e.p,{children:["Figures ",(0,i.jsx)(e.code,{children:"a"}),", ",(0,i.jsx)(e.code,{children:"b"})," and ",(0,i.jsx)(e.code,{children:"c"})," represent the same program, each with slight modifications (green highlight) to demonstrate cost allocation and mid-stack inlining."]}),"\n",(0,i.jsxs)(e.p,{children:["Let's build the program in Figure ",(0,i.jsx)(e.code,{children:"a"})," (output condensed for relevance),"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsxs)(e.code,{className:"hljs language-sh",children:["$ GOOS=darwin GOARCH=amd64 go build -gcflags=",(0,i.jsx)(e.span,{className:"hljs-string",children:"'-m=2'"})," midstack/main.go                      \n",(0,i.jsx)(e.span,{className:"hljs-comment",children:"# command-line-arguments"}),"\nmidstack/main.go:30:6: can inline Sum with cost 4 as: func(int, int) int { ",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"return"})," a + b }\nmidstack/main.go:23:6: can inline MidPoint with cost 28 as: func(Point, Point) Point { ",(0,i.jsx)(e.span,{className:"hljs-built_in",children:"return"})," Point{...} }\nmidstack/main.go:25:9: inlining call to Sum\nmidstack/main.go:26:9: inlining call to Sum\nmidstack/main.go:18:6: cannot inline PrintPoint: ",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"function"})," too complex: cost 89 exceeds budget 80\nmidstack/main.go:20:13: inlining call to fmt.Println\nmidstack/main.go:10:6: cannot inline main: ",(0,i.jsx)(e.span,{className:"hljs-keyword",children:"function"})," too complex: cost 114 exceeds budget 80\nmidstack/main.go:13:26: inlining call to MidPoint\nmidstack/main.go:13:26: inlining call to Sum\nmidstack/main.go:13:26: inlining call to Sum\n"]})}),"\n",(0,i.jsxs)(e.p,{children:["You can see that each function has a cost assigned to it, which is compared against the budget (",(0,i.jsx)(e.code,{children:"80"}),") to decide whether the function can be inlined. The functions ",(0,i.jsx)(e.code,{children:"MidPoint"})," (cost: ",(0,i.jsx)(e.code,{children:"28"}),") and ",(0,i.jsx)(e.code,{children:"Sum"})," (cost: ",(0,i.jsx)(e.code,{children:"4"}),") are inline-able, whereas ",(0,i.jsx)(e.code,{children:"PrintPoint"})," (cost: ",(0,i.jsx)(e.code,{children:"89"}),") and ",(0,i.jsx)(e.code,{children:"main"})," (cost: ",(0,i.jsx)(e.code,{children:"114"}),") are not."]}),"\n",(0,i.jsx)(e.p,{children:"I will also use this example to showcase the two forms of inlining,"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsxs)(e.li,{children:["Leaf inlining","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Earlier, only functions that did not call other functions (bottom of the call stack) were eligible for inlining. Once a leaf function is inlined, the resulting code can be inlined into its caller, a recursive process."}),"\n",(0,i.jsxs)(e.li,{children:["For example, ",(0,i.jsx)(e.code,{children:"Sum"})," (a leaf function) gets inlined into ",(0,i.jsx)(e.code,{children:"MidPoint"}),". Next, ",(0,i.jsx)(e.code,{children:"MidPoint"})," (a leaf function now) gets inlined into ",(0,i.jsx)(e.code,{children:"main"}),"."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["Mid-stack inlining","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"Now, non-leaf functions are also eligible for inlining."}),"\n",(0,i.jsxs)(e.li,{children:["For example, in Figure ",(0,i.jsx)(e.code,{children:"c"}),", the function ",(0,i.jsx)(e.code,{children:"Sum"})," is marked with the directive ",(0,i.jsx)(e.code,{children:"//go:noinline"}),", making it non-eligible for inlining. Even though ",(0,i.jsx)(e.code,{children:"MidPoint"})," calls ",(0,i.jsx)(e.code,{children:"Sum"}),", it is allocated a cost of ",(0,i.jsx)(e.code,{children:"76"}),", making it eligible for inlining."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{children:"References"}),"\n",(0,i.jsxs)(e.ol,{children:["\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-5-4053",children:"Inlining optimisations in Go - Dave Cheney"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go#easy-footnote-bottom-1-4076",children:"Mid-stack inlining in Go - Dave Cheney"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"/7/6_inlining_2019_bright_victories_and_hidden_defeats.pdf",children:"Inlining - bright victories and hidden defeats"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast",children:"Five things that make Go fast - Dave Cheney"})}),"\n",(0,i.jsx)(e.li,{children:(0,i.jsx)(e.a,{href:"/7/7_talk_Mid-stack_inlining_in_the_Go_compiler.pdf",children:"Mid-stack inlining in the Go compiler - David Lazar"})}),"\n"]})]})}e.default=function(n){var e=void 0===n?{}:n,s=Object.assign({},(0,l.ah)(),e.components).wrapper;return s?(0,i.jsx)(s,Object.assign({},e,{children:(0,i.jsx)(c,e)})):c(e)}},5711:function(n){n.exports={carousel:"MDImage_carousel__N8hEe"}}},function(n){n.O(0,[774,888,179],(function(){return e=1883,n(n.s=e);var e}));var e=n.O();_N_E=e}]);