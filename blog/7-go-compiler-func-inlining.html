<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/2c09a92627824155.css" as="style"/><link rel="stylesheet" href="/_next/static/css/2c09a92627824155.css" data-n-g=""/><link rel="preload" href="/_next/static/css/9d581defcc99acf1.css" as="style"/><link rel="stylesheet" href="/_next/static/css/9d581defcc99acf1.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-514908bffb652963.js" defer=""></script><script src="/_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="/_next/static/chunks/main-7e73d61bce33e887.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6ebfa373a417a20.js" defer=""></script><script src="/_next/static/chunks/pages/blog/7-go-compiler-func-inlining-83e30f52d85abf10.js" defer=""></script><script src="/_next/static/TAiowSXvcX1kpnmOCRxyE/_buildManifest.js" defer=""></script><script src="/_next/static/TAiowSXvcX1kpnmOCRxyE/_ssgManifest.js" defer=""></script><script src="/_next/static/TAiowSXvcX1kpnmOCRxyE/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><header class="Header_header__VYZ3G"><div class="max-width-container"><h2><a href="/">Ben Sooraj</a></h2><ul><li><a href="/about">About</a></li><li><a href="/blog">Blog</a></li></ul></div></header><main class="max-width-container main"><h1 class="Markdown_postTitle__HEeQS">Function Inlining in Golang</h1>
<h2>What is Inlining?</h2>
<p>Inlining is a form of compiler optimisation where the compiler replaces a function call with the function&#x27;s body to reduce the overhead of the function call. The following diagram crudely shows what this process looks like.</p>
<img class="MDImage_carousel__N8hEe" src="/7/0_func_inlining.png" alt="Function inlining illustration" width="100%" height="100%"/>
<p>Let&#x27;s take an example Go program.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// main.go</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> a <span class="hljs-type">int</span> = <span class="hljs-number">10</span>
	<span class="hljs-keyword">var</span> b <span class="hljs-type">int</span> = <span class="hljs-number">20</span>
	
	c := sum(a, b)
	<span class="hljs-built_in">print</span>(c)
	
	d := difference(b, a)
	<span class="hljs-built_in">print</span>(d)
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {
	<span class="hljs-keyword">return</span> a + b
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">difference</span><span class="hljs-params">(a <span class="hljs-type">int</span>, b <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> {
	<span class="hljs-keyword">return</span> a - b
}
</code></pre>
<p>Build the above program using the following command,</p>
<pre><code class="hljs language-sh">GOOS=darwin GOARCH=amd64 go build -o expinline_darwin_amd64
</code></pre>
<p>To understand inlining in practice, we will have to look at the assembly code generated by the above command and for that, we will have to disassemble the binary <code>expinline_darwin_amd64</code>.</p>
<p>Before we do that, let&#x27;s look at the symbols (I am looking for the function names here),</p>
<pre><code class="hljs language-sh">$ objdump --syms expinline_darwin_amd64 | grep -E <span class="hljs-string">&#x27;_main.main|sum|difference&#x27;</span>        
0000000001057600 l     F __TEXT,__text _main.main
0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume
0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize
000000000102c9c0 l     F __TEXT,__text _runtime.resumeG
</code></pre>
<p>You will see no symbols for the functions <code>sum</code> and <code>difference</code>. To understand why this is the case, let&#x27;s dig deeper into the assembly code,</p>
<pre><code class="hljs language-sh">$ objdump expinline_darwin_amd64 --disassemble-symbols=_main.main
</code></pre>
<img class="MDImage_carousel__N8hEe" src="/7/1_opt_and_inline_asm.jpeg" alt="" width="100%" height="100%"/>
<p>Surprisingly, I see no function calls (<code>callq</code>) to <code>sum</code> or <code>difference</code>. It looks as if the compiler was smart enough to reduce the whole program to calling the print function on two absolute constants <code>30</code> (<code>a</code>+<code>b</code>) and <code>10</code> (<code>b</code>-<code>a</code>) denoted by <code>movl $30, %eax</code> and <code>movl $10, %eax</code> respectively, before the call to <code>print</code>.</p>
<p>Let&#x27;s turn off this compiler optimisation to preserve calculation logic and reevaluate the results.</p>
<pre><code class="hljs language-sh">$ GOOS=darwin GOARCH=amd64 go build -gcflags=<span class="hljs-string">&#x27;-N&#x27;</span> -o expinline_darwin_amd64_no_op
</code></pre>
<p>And examine the <code>_main.main</code> symbol again,</p>
<pre><code class="hljs language-sh">$ objdump expinline_darwin_amd64_no_op --disassemble-symbols=_main.main
</code></pre>
<img class="MDImage_carousel__N8hEe" src="/7/2_no_opt_asm.jpeg" alt="" width="100%" height="100%"/>
<p>Now you can observe that there is addition logic between the offsets <code>105762a</code> and <code>105763c</code>  and subtraction logic between the offsets <code>1057665</code> and <code>105767c</code>. Again, there are no function calls (<code>callq</code>) to <code>sum</code> or <code>difference</code>, indicating that they have been inlined into the caller <code>main()</code>.</p>
<p>Along with turning off the optimisation, <code>inlining</code> can also be turned off.</p>
<pre><code class="hljs language-sh">$ GOOS=darwin GOARCH=amd64 go build -gcflags=<span class="hljs-string">&#x27;-N -l&#x27;</span> -o expinline_darwin_amd64_no_op_no_inline
</code></pre>
<p>If you examine the symbols now, you can see the missing functions as well:</p>
<pre><code class="hljs language-sh">$ objdump --syms expinline_darwin_amd64_no_op_no_inline | grep -E <span class="hljs-string">&#x27;_main.main|sum|difference&#x27;</span>
00000000010576e0 l     F __TEXT,__text _main.difference
0000000001057600 l     F __TEXT,__text _main.main
00000000010576a0 l     F __TEXT,__text _main.<span class="hljs-built_in">sum</span>
0000000001014ba0 l     F __TEXT,__text _runtime.(*limiterEvent).consume
0000000001025000 l     F __TEXT,__text _runtime.(*pallocBits).summarize
000000000102c9c0 l     F __TEXT,__text _runtime.resumeG
</code></pre>
<p>And here&#x27;s the disassembled code,</p>
<img class="MDImage_carousel__N8hEe" src="/7/3_no_opt_no_inline_asm.jpeg" alt="" width="100%" height="100%"/>
<h2>Why inline?</h2>
<h3>Improves performance by minimising the function call overheads</h3>
<p>These overheads include stack manipulation, CPU register loading/unloading, branching, handling return values, etc.</p>
<p>Let&#x27;s perform a quick benchmark test to gauge the gain in performance. The following bench function calls the <code>sum</code> and <code>difference</code> functions,</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// main_bench_test.go</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span>

<span class="hljs-keyword">var</span> Result <span class="hljs-type">int</span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkSpecialBinomialProduct</span><span class="hljs-params">(b *testing.B)</span></span> {
	<span class="hljs-keyword">var</span> r <span class="hljs-type">int</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ {
		r = sum(i, i+<span class="hljs-number">7</span>) * difference(i+<span class="hljs-number">7</span>, i)
	}
	Result = r
}
</code></pre>
<p>Run it with all the default optimisations turned on,</p>
<pre><code class="hljs language-sh">$ go <span class="hljs-built_in">test</span> -run=<span class="hljs-string">&#x27;^$&#x27;</span> -bench=. -benchmem -benchtime=10s -count=10 &gt; bench_with_inlining.txt
</code></pre>
<p>Now add the compiler directive <code>//go:noinline</code> just above the function definitions of <code>sum</code> and <code>difference</code> and rerun the bench,</p>
<pre><code class="hljs language-sh">$ go <span class="hljs-built_in">test</span> -run=<span class="hljs-string">&#x27;^$&#x27;</span> -bench=. -benchmem -benchtime=10s -count=10 &gt; bench_with_no_inlining.txt
</code></pre>
<p>Finally, compare the results from the benchmark above,</p>
<pre><code class="hljs language-sh">$ benchstat {bench_with_no_inlining,bench_with_inlining}.txt
</code></pre>
<img class="MDImage_carousel__N8hEe" src="/7/4_benchstat.png" alt="" width="100%" height="100%"/>
<p>Albeit a contrived example, you can see a performance improvement of ~78%.</p>
<p>Two things to note about inlining.</p>
<ul>
<li>It is a trade-off between space (increased binary size) and time (performance). This is because the function&#x27;s body is copied to everywhere it is called.</li>
<li>It yields diminishing returns as the functions get larger or more complex because the call overhead to these functions becomes relatively negligible.</li>
</ul>
<h3>Augments escape analysis</h3>
<p>Escape analysis is a compiler optimisation technique that determines if a value can be on the stack frame for the function constructing it or if the value must “escape” to the heap.</p>
<p>Let&#x27;s consider the following example,</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// escape/main.go</span>
<span class="hljs-keyword">package</span> main

<span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span> {
	x, y <span class="hljs-type">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPoint</span><span class="hljs-params">(x, y <span class="hljs-type">int</span>)</span></span> *Point {
	<span class="hljs-keyword">return</span> &amp;Point{x, y} <span class="hljs-comment">// 8:9</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	p1 := NewPoint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>) <span class="hljs-comment">// 12:16</span>
	p2 := NewPoint(<span class="hljs-number">30</span>, <span class="hljs-number">40</span>) <span class="hljs-comment">// 13:16</span>
	
	<span class="hljs-built_in">print</span>(p1.x, p2.y)
}
</code></pre>
<p>Build the above program with the <code>-m</code> compiler flag to print optimisation decisions,</p>
<pre><code class="hljs language-sh">$ go build -gcflags=<span class="hljs-string">&#x27;-m=1&#x27;</span> escape/main.go         
<span class="hljs-comment"># command-line-arguments</span>
escape/main.go:7:6: can inline NewPoint
escape/main.go:11:6: can inline main
escape/main.go:12:16: inlining call to NewPoint
escape/main.go:13:16: inlining call to NewPoint
escape/main.go:8:9: &amp;Point{...} escapes to heap
escape/main.go:12:16: &amp;Point{...} does not escape
escape/main.go:13:16: &amp;Point{...} does not escape
</code></pre>
<p>Since <code>NewPoint</code> is expanded inside the <code>main</code> function, the lifetimes of <code>Point{10, 20}</code> and <code>Point{30, 40}</code> are bound within the <code>main</code>&#x27;s scope.</p>
<p>Now build with inlining turned off,</p>
<pre><code class="hljs language-sh">$ go build -gcflags=<span class="hljs-string">&#x27;-m=1 -l&#x27;</span> escape/main.go
<span class="hljs-comment"># command-line-arguments</span>
escape/main.go:8:9: &amp;Point{...} escapes to heap
</code></pre>
<p>Each call to <code>NewPoint(..)</code> will result in a <code>Point</code> object allocated to the heap memory.</p>
<h2>How does the compiler do that?</h2>
<p>Go&#x27;s compiler uses a combination of budget and cost to determine whether to inline a function. Every function has a cost compared against a budget (threshold).</p>
<p>A function&#x27;s cost is calculated using the complexity of the statements within the function body (one unit per node in the AST). And the budget changes from one release (40 in Go 1.6 | <a href="https://github.com/golang/go/blob/7bc40ffb05d8813bf9b41a331b45d37216f9e747/src/cmd/compile/internal/gc/inl.go#L14" class="Markdown_link__M8PUN">src/cmd/compile/internal/gc/inl.go</a>) to another (80 | <a href="https://github.com/golang/go/blob/4be921d888d3a68c51e38d4c615a4438c7b2cb30/src/cmd/compile/internal/inline/inl.go#L47" class="Markdown_link__M8PUN">src/cmd/compile/internal/inline/inl.go</a>).</p>
<p>Let&#x27;s take the following example,</p>
<img class="MDImage_carousel__N8hEe" src="/7/5_cost_budget_midstack.jpeg" alt="" width="100%" height="100%"/>
<p>Figures <code>a</code>, <code>b</code> and <code>c</code> represent the same program, each with slight modifications (green highlight) to demonstrate cost allocation and mid-stack inlining.</p>
<p>Let&#x27;s build the program in Figure <code>a</code> (output condensed for relevance),</p>
<pre><code class="hljs language-sh">$ GOOS=darwin GOARCH=amd64 go build -gcflags=<span class="hljs-string">&#x27;-m=2&#x27;</span> midstack/main.go                      
<span class="hljs-comment"># command-line-arguments</span>
midstack/main.go:30:6: can inline Sum with cost 4 as: func(int, int) int { <span class="hljs-built_in">return</span> a + b }
midstack/main.go:23:6: can inline MidPoint with cost 28 as: func(Point, Point) Point { <span class="hljs-built_in">return</span> Point{...} }
midstack/main.go:25:9: inlining call to Sum
midstack/main.go:26:9: inlining call to Sum
midstack/main.go:18:6: cannot inline PrintPoint: <span class="hljs-keyword">function</span> too complex: cost 89 exceeds budget 80
midstack/main.go:20:13: inlining call to fmt.Println
midstack/main.go:10:6: cannot inline main: <span class="hljs-keyword">function</span> too complex: cost 114 exceeds budget 80
midstack/main.go:13:26: inlining call to MidPoint
midstack/main.go:13:26: inlining call to Sum
midstack/main.go:13:26: inlining call to Sum
</code></pre>
<p>You can see that each function has a cost assigned to it, which is compared against the budget (<code>80</code>) to decide whether the function can be inlined. The functions <code>MidPoint</code> (cost: <code>28</code>) and <code>Sum</code> (cost: <code>4</code>) are inline-able, whereas <code>PrintPoint</code> (cost: <code>89</code>) and <code>main</code> (cost: <code>114</code>) are not.</p>
<p>I will also use this example to showcase the two forms of inlining,</p>
<ol>
<li>Leaf inlining<!-- -->
<ul>
<li>Earlier, only functions that did not call other functions (bottom of the call stack) were eligible for inlining. Once a leaf function is inlined, the resulting code can be inlined into its caller, a recursive process.</li>
<li>For example, <code>Sum</code> (a leaf function) gets inlined into <code>MidPoint</code>. Next, <code>MidPoint</code> (a leaf function now) gets inlined into <code>main</code>.</li>
</ul>
</li>
<li>Mid-stack inlining<!-- -->
<ul>
<li>Now, non-leaf functions are also eligible for inlining.</li>
<li>For example, in Figure <code>c</code>, the function <code>Sum</code> is marked with the directive <code>//go:noinline</code>, making it non-eligible for inlining. Even though <code>MidPoint</code> calls <code>Sum</code>, it is allocated a cost of <code>76</code>, making it eligible for inlining.</li>
</ul>
</li>
</ol>
<h2>References</h2>
<ol>
<li><a href="https://dave.cheney.net/2020/04/25/inlining-optimisations-in-go#easy-footnote-5-4053" class="Markdown_link__M8PUN">Inlining optimisations in Go - Dave Cheney</a></li>
<li><a href="https://dave.cheney.net/2020/05/02/mid-stack-inlining-in-go#easy-footnote-bottom-1-4076" class="Markdown_link__M8PUN">Mid-stack inlining in Go - Dave Cheney</a></li>
<li><a href="/7/6_inlining_2019_bright_victories_and_hidden_defeats.pdf" class="Markdown_link__M8PUN">Inlining - bright victories and hidden defeats</a></li>
<li><a href="https://dave.cheney.net/2014/06/07/five-things-that-make-go-fast" class="Markdown_link__M8PUN">Five things that make Go fast - Dave Cheney</a></li>
<li><a href="/7/7_talk_Mid-stack_inlining_in_the_Go_compiler.pdf" class="Markdown_link__M8PUN">Mid-stack inlining in the Go compiler - David Lazar</a></li>
</ol></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/7-go-compiler-func-inlining","query":{},"buildId":"TAiowSXvcX1kpnmOCRxyE","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>