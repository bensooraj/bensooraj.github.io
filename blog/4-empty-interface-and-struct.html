<!DOCTYPE html><html lang="en"><head><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.4.0/styles/github-dark.min.css"/><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="./_next/static/css/8ffa8c5c9f5551ae.css" as="style"/><link rel="stylesheet" href="./_next/static/css/8ffa8c5c9f5551ae.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="./_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="./_next/static/chunks/webpack-ed47cc4bbff8e103.js" defer=""></script><script src="./_next/static/chunks/framework-91d7f78b5b4003c8.js" defer=""></script><script src="./_next/static/chunks/main-7e73d61bce33e887.js" defer=""></script><script src="./_next/static/chunks/pages/_app-e6ebfa373a417a20.js" defer=""></script><script src="./_next/static/chunks/pages/blog/4-empty-interface-and-struct-16329ba61ea5d8b7.js" defer=""></script><script src="./_next/static/oaVD9cy8boZ1Gb-CNoTp4/_buildManifest.js" defer=""></script><script src="./_next/static/oaVD9cy8boZ1Gb-CNoTp4/_ssgManifest.js" defer=""></script><script src="./_next/static/oaVD9cy8boZ1Gb-CNoTp4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div><header class="Header_header__VYZ3G"><div class="max-width-container"><h2><a href="/">Ben Sooraj</a></h2><ul><li><a href="/about">About</a></li><li><a href="/blog">Blog</a></li></ul></div></header><main class="max-width-container main"><h1 class="Markdown_postTitle__HEeQS">The empty interface and the empty struct in golang</h1>
<p>An <code>interface</code> is a collection or set of method declarations. A data type implements or satisfies an <code>interface</code> if it at least defines the methods declared by the <code>interface</code>.</p>
<h2>Empty interface</h2>
<p>An empty interface <code>interface{}</code> has zero methods. So, in essence, any data type implements or satisfies an empty interface. Let&#x27;s take the following example:</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> Container []<span class="hljs-keyword">interface</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span></span> Put(elem <span class="hljs-keyword">interface</span>{}) {
    *c = <span class="hljs-built_in">append</span>(*c, elem)
    <span class="hljs-keyword">switch</span> elem.(<span class="hljs-keyword">type</span>) {
    <span class="hljs-keyword">case</span> <span class="hljs-type">int</span>:
        fmt.Println(<span class="hljs-string">&quot;Put &quot;</span>, elem, <span class="hljs-string">&quot; of type int&quot;</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-type">string</span>:
        fmt.Println(<span class="hljs-string">&quot;Put &quot;</span>, elem, <span class="hljs-string">&quot; of type string&quot;</span>)
    <span class="hljs-keyword">default</span>:
        fmt.Println(<span class="hljs-string">&quot;Put &quot;</span>, elem, <span class="hljs-string">&quot; of type unknown&quot;</span>)
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Container)</span></span> Pop() <span class="hljs-keyword">interface</span>{} {
    elem := (*c)[<span class="hljs-number">0</span>]
    *c = (*c)[<span class="hljs-number">1</span>:]
    <span class="hljs-keyword">return</span> elem
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    allContainer := &amp;Container{}

    allContainer.Put(<span class="hljs-string">&quot;Hello&quot;</span>)
    allContainer.Put(<span class="hljs-number">213</span>)
    allContainer.Put(<span class="hljs-number">123.321</span>)

    fmt.Printf(<span class="hljs-string">&quot;allContainer: %+v\n\n&quot;</span>, allContainer)
}
</code></pre>
<p>Output:</p>
<pre><code class="hljs language-sh">$ go run main.go
Put  Hello  of <span class="hljs-built_in">type</span> string
Put  213  of <span class="hljs-built_in">type</span> int
Put  123.321  of <span class="hljs-built_in">type</span> unknown
allContainer: &amp;[Hello 213 123.321]
</code></pre>
<p>In the above example, the data type <code>Container</code> is a slice of empty interfaces with two methods defined on it, <code>Put()</code> and <code>Pop()</code>. It loosely resembles a <em>First In, Last Out</em> stack.</p>
<p>The <code>Put()</code> method takes an <code>interface{}</code> as the input argument and appends it to the slice of <code>interface{}</code>s. This means that it can accept a string, an integer, a float or any other simple and composite data type as its input argument. You can access the underlying type of <code>elem</code>, an <code>interface{}</code>, using <code>elem.(type)</code>.</p>
<p>This approach does have its disadvantages though. One being that you should implement type assertions, checks or type specific logics to avoid any surprises during runtime.</p>
<h2>Empty struct</h2>
<p>To quote the Golang spec:</p>
<blockquote>
<p>A struct is a sequence of named elements, called fields, each of which has a name and a type.</p>
</blockquote>
<p>Let&#x27;s take an example</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// A struct with 5 fields.</span>
<span class="hljs-keyword">struct</span> {
    x, y <span class="hljs-type">int</span>
    u <span class="hljs-type">float32</span>
    A *[]<span class="hljs-type">int</span>
    F <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>
}
</code></pre>
<p>An empty struct is a struct data type with zero fields:</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// Named type</span>
<span class="hljs-keyword">type</span> EmptyStruct <span class="hljs-keyword">struct</span>{}

<span class="hljs-comment">// Variable declaration</span>
<span class="hljs-keyword">var</span> es <span class="hljs-keyword">struct</span>{}

<span class="hljs-comment">// Or use it directly!</span>
<span class="hljs-keyword">struct</span>{}{}
</code></pre>
<p>The size or width of a <code>struct</code> is defined as the sum of its constituent types. An empty <code>struct</code>, since it has no fields within it, has a size or width of zero. Zero bytes!</p>
<p>Just like regular structs you can define methods on empty structs as well. Sort of like a zero sized container for methods:</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> EmptyStruct <span class="hljs-keyword">struct</span>{}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(es *EmptyStruct)</span></span> WhoAmI() {
    fmt.Println(<span class="hljs-string">&quot;I am an empty struct!&quot;</span>)
}
</code></pre>
<p>Empty structs find its best use case in channel signalling. Many a mere mortals such as me have used booleans or integers to notify an event over a channel.</p>
<p>The following example prints the current time at every 500 milliseconds and times out after 3 seconds,</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printFor3Seconds</span><span class="hljs-params">(doneChannel <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{})</span></span> {
    ticker := time.NewTicker(<span class="hljs-number">500</span> * time.Millisecond)
    timeout := time.After(<span class="hljs-number">3</span> * time.Second)

    <span class="hljs-keyword">for</span> {
        <span class="hljs-keyword">select</span> {
        <span class="hljs-keyword">case</span> t := &lt;-ticker.C:
            fmt.Printf(<span class="hljs-string">&quot;Tik tik: %v\n&quot;</span>, t)
        <span class="hljs-keyword">case</span> &lt;-timeout:
            fmt.Printf(<span class="hljs-string">&quot;Timeout at: %v\n&quot;</span>, time.Now())
            doneChannel &lt;- <span class="hljs-keyword">struct</span>{}{}
            <span class="hljs-keyword">return</span>
        }
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
    doneChannel := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>{}, <span class="hljs-number">1</span>)

    <span class="hljs-keyword">go</span> printFor3Seconds(doneChannel)

    &lt;-doneChannel
}

<span class="hljs-comment">// Output</span>
<span class="hljs-comment">// $ go run 1.go</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:36.750631 +0530 IST m=+0.501680080</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:37.250303 +0530 IST m=+1.001337269</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:37.750696 +0530 IST m=+1.501714888</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:38.253708 +0530 IST m=+2.004711715</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:38.752804 +0530 IST m=+2.503793180</span>
<span class="hljs-comment">// Tik tik: 2020-09-16 08:25:39.251941 +0530 IST m=+3.002914584</span>
<span class="hljs-comment">// Timeout at: 2020-09-16 08:25:39.251999 +0530 IST m=+3.002972846</span>
</code></pre>
<p>Instead of <code>doneChannel &lt;- 0</code> or <code>doneChannel &lt;- true</code>, I am using <code>doneChannel &lt;- struct{}{}</code> for channel signalling. Using booleans or integers for channel signalling involves memory allocation, copying over the element etc.</p>
<p>We can use empty structs for simulating sets as well,</p>
<pre><code class="hljs language-go">intSet := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-keyword">struct</span>{})
empty := <span class="hljs-keyword">struct</span>{}{}

<span class="hljs-comment">// We are setting empty as the value for 1, because the</span>
<span class="hljs-comment">// value is meaningless</span>
intSet[<span class="hljs-number">1</span>] = empty
<span class="hljs-keyword">if</span> _, ok := intSet[<span class="hljs-number">1</span>]; ok {
    fmt.Println(<span class="hljs-string">&quot;1 is in the set&quot;</span>)
}

<span class="hljs-comment">// 2 is not one of intSet&#x27;s keys</span>
<span class="hljs-keyword">if</span> _, ok := intSet[<span class="hljs-number">2</span>]; !ok {
    fmt.Println(<span class="hljs-string">&quot;2 is not in the set&quot;</span>)
}
</code></pre>
<h2>Resources:</h2>
<ol>
<li><a href="https://golang.org/ref/spec#Struct_types" class="Markdown_link__M8PUN">The Go Programming Language Specification</a></li>
<li><a href="https://dave.cheney.net/2014/03/25/the-empty-struct" class="Markdown_link__M8PUN">The empty struct - Dave Cheney</a></li>
</ol>
<hr/>
<p>Note: <em>This article is not an in-depth tutorial or treatment of Golang&#x27;s syntax, semantics, design or implementation, but a journal of my learnings.</em></p></main></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{}},"page":"/blog/4-empty-interface-and-struct","query":{},"buildId":"oaVD9cy8boZ1Gb-CNoTp4","assetPrefix":".","nextExport":true,"autoExport":true,"isFallback":false,"scriptLoader":[]}</script></body></html>