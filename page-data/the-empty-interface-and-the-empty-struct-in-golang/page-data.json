{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/the-empty-interface-and-the-empty-struct-in-golang","result":{"data":{"post":{"__typename":"MdxPost","slug":"/the-empty-interface-and-the-empty-struct-in-golang","title":"The empty interface and the empty struct in golang","date":"01.09.2020","tags":[{"name":"golang","slug":"golang"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The empty interface and the empty struct in golang\",\n  \"date\": \"2020-09-01T11:34:32.000Z\",\n  \"draft\": false,\n  \"tags\": [\"golang\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"An \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface\"), \" is a collection or set of method declarations. A data type implements or satisfies an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface\"), \" if it at least defines the methods declared by the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface\"), \".\"), mdx(\"h2\", null, \"Empty interface\"), mdx(\"p\", null, \"An empty interface \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface{}\"), \" has zero methods. So, in essence, any data type implements or satisfies an empty interface. Let's take the following example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type Container []interface{}\\n\\nfunc (c *Container) Put(elem interface{}) {\\n    *c = append(*c, elem)\\n    switch elem.(type) {\\n    case int:\\n        fmt.Println(\\\"Put \\\", elem, \\\" of type int\\\")\\n    case string:\\n        fmt.Println(\\\"Put \\\", elem, \\\" of type string\\\")\\n    default:\\n        fmt.Println(\\\"Put \\\", elem, \\\" of type unknown\\\")\\n    }\\n}\\n\\nfunc (c *Container) Pop() interface{} {\\n    elem := (*c)[0]\\n    *c = (*c)[1:]\\n    return elem\\n}\\n\\nfunc main() {\\n    allContainer := &Container{}\\n\\n    allContainer.Put(\\\"Hello\\\")\\n    allContainer.Put(213)\\n    allContainer.Put(123.321)\\n\\n    fmt.Printf(\\\"allContainer: %+v\\\\n\\\\n\\\", allContainer)\\n}\\n\")), mdx(\"p\", null, \"Output:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sh\"\n  }, \"$ go run main.go\\nPut  Hello  of type string\\nPut  213  of type int\\nPut  123.321  of type unknown\\nallContainer: &[Hello 213 123.321]\\n\")), mdx(\"p\", null, \"In the above example, the data type \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Container\"), \" is a slice of empty interfaces with two methods defined on it, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Put()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Pop()\"), \". It loosely resembles a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"First In, Last Out\"), \" stack.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Put()\"), \" method takes an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface{}\"), \" as the input argument and appends it to the slice of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface{}\"), \"s. This means that it can accept a string, an integer, a float or any other simple and composite data type as its input argument. You can access the underlying type of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"elem\"), \", an \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"interface{}\"), \", using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"elem.(type)\"), \".\"), mdx(\"p\", null, \"This approach does have its disadvantages though. One being that you should implement type assertions, checks or type specific logics to avoid any surprises during runtime.\"), mdx(\"h2\", null, \"Empty struct\"), mdx(\"p\", null, \"To quote the Golang spec:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"A struct is a sequence of named elements, called fields, each of which has a name and a type.\")), mdx(\"p\", null, \"Let's take an example\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// A struct with 5 fields.\\nstruct {\\n    x, y int\\n    u float32\\n    A *[]int\\n    F func()\\n}\\n\")), mdx(\"p\", null, \"An empty struct is a struct data type with zero fields:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// Named type\\ntype EmptyStruct struct{}\\n\\n// Variable declaration\\nvar es struct{}\\n\\n// Or use it directly!\\nstruct{}{}\\n\")), mdx(\"p\", null, \"The size or width of a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \" is defined as the sum of its constituent types. An empty \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \", since it has no fields within it, has a size or width of zero. Zero bytes!\"), mdx(\"p\", null, \"Just like regular structs you can define methods on empty structs as well. Sort of like a zero sized container for methods:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type EmptyStruct struct{}\\n\\nfunc (es *EmptyStruct) WhoAmI() {\\n    fmt.Println(\\\"I am an empty struct!\\\")\\n}\\n\")), mdx(\"p\", null, \"Empty structs find its best use case in channel signalling. Many a mere mortals such as me have used booleans or integers to notify an event over a channel.\"), mdx(\"p\", null, \"The following example prints the current time at every 500 milliseconds and times out after 3 seconds,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func printFor3Seconds(doneChannel chan struct{}) {\\n    ticker := time.NewTicker(500 * time.Millisecond)\\n    timeout := time.After(3 * time.Second)\\n\\n    for {\\n        select {\\n        case t := <-ticker.C:\\n            fmt.Printf(\\\"Tik tik: %v\\\\n\\\", t)\\n        case <-timeout:\\n            fmt.Printf(\\\"Timeout at: %v\\\\n\\\", time.Now())\\n            doneChannel <- struct{}{}\\n            return\\n        }\\n    }\\n}\\n\\nfunc main() {\\n    doneChannel := make(chan struct{}, 1)\\n\\n    go printFor3Seconds(doneChannel)\\n\\n    <-doneChannel\\n}\\n\\n// Output\\n// $ go run 1.go\\n// Tik tik: 2020-09-16 08:25:36.750631 +0530 IST m=+0.501680080\\n// Tik tik: 2020-09-16 08:25:37.250303 +0530 IST m=+1.001337269\\n// Tik tik: 2020-09-16 08:25:37.750696 +0530 IST m=+1.501714888\\n// Tik tik: 2020-09-16 08:25:38.253708 +0530 IST m=+2.004711715\\n// Tik tik: 2020-09-16 08:25:38.752804 +0530 IST m=+2.503793180\\n// Tik tik: 2020-09-16 08:25:39.251941 +0530 IST m=+3.002914584\\n// Timeout at: 2020-09-16 08:25:39.251999 +0530 IST m=+3.002972846\\n\")), mdx(\"p\", null, \"Instead of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doneChannel <- 0\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doneChannel <- true\"), \", I am using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doneChannel <- struct{}{}\"), \" for channel signalling. Using booleans or integers for channel signalling involves memory allocation, copying over the element etc.\"), mdx(\"p\", null, \"We can use empty structs for simulating sets as well,\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"intSet := make(map[int]struct{})\\nempty := struct{}{}\\n\\n// We are setting empty as the value for 1, because the\\n// value is meaningless\\nintSet[1] = empty\\nif _, ok := intSet[1]; ok {\\n    fmt.Println(\\\"1 is in the set\\\")\\n}\\n\\n// 2 is not one of intSet's keys\\nif _, ok := intSet[2]; !ok {\\n    fmt.Println(\\\"2 is not in the set\\\")\\n}\\n\")), mdx(\"h2\", null, \"Resources:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://golang.org/ref/spec#Struct_types\"\n  }, \"The Go Programming Language Specification\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://dave.cheney.net/2014/03/25/the-empty-struct\"\n  }, \"The empty struct - Dave Cheney\"))), mdx(\"hr\", null), mdx(\"p\", null, \"Note: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This article is not an in-depth tutorial or treatment of Golang's syntax, semantics, design or implementation, but a journal of my learnings.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"An  interface  is a collection or set of method declarations. A data type implements or satisfies an  interface  if it at least defines the…","timeToRead":1,"banner":null}},"pageContext":{"slug":"/the-empty-interface-and-the-empty-struct-in-golang","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}