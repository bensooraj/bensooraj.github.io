{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-post-query-tsx","path":"/go-rp-cs-remote-procedure-calls","result":{"data":{"post":{"__typename":"MdxPost","slug":"/go-rp-cs-remote-procedure-calls","title":"Go RPCs (Remote Procedure Calls)","date":"28.05.2021","tags":[{"name":"golang","slug":"golang"}],"description":null,"canonicalUrl":null,"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Go RPCs (Remote Procedure Calls)\",\n  \"date\": \"2021-05-28T05:34:32.000Z\",\n  \"draft\": false,\n  \"tags\": [\"golang\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h3\", null, \"Introduction\"), mdx(\"p\", null, \"Go's \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" package enables communication across multiple machines, sort of like inter-process communication via funtion/method/procedure calls.\"), mdx(\"p\", null, \"As the Go documentation puts it:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Package \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" provides access to the exported methods of an object across a network or other I/O connection. A server registers an object, making it visible as a service with the name of the type of the object.\")), mdx(\"p\", null, \"The object that is registered with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" server can be either primitive/builtin data types (\", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"int\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"string\"), \" etc.) or user-defined ones (such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \"s). I would usually prefer a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"struct\"), \".\"), mdx(\"p\", null, \"Under the hood, by default, Go uses \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gob\"), \" for serializing and deserializing the remote procedure calls. This is configurable, that is, you can plug-in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"JSON\"), \" or other custom codecs.\"), mdx(\"h3\", null, \"Prerequisites\"), mdx(\"p\", null, \"The methods which define actions on the registered object must adhere to a specific function signature. The methods,\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"and its type(s) must be exported (uppercased)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"have two arguments, both exported (or builtin) types.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"their second argument is a pointer.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"must have one return type, \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"error\"), \".\")), mdx(\"p\", null, \"Essentially the method signature looks like the following:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func (t *T) MethodName(argType T1, replyType *T2) error\\n\")), mdx(\"h3\", null, \"Implementation\"), mdx(\"p\", null, \"Let's look at a dummy blog server and a client interacting with each other via \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \".\"), mdx(\"h5\", null, \"a. Types\"), mdx(\"p\", null, \"It's a good idea to wrap the object, along with the methods and types, into a package of its own. This makes it easier for both the server and client implementations to agree on common type definitions.\"), mdx(\"p\", null, \"In the following code, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Blog\"), \" will be registered with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" server.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"type Blog struct {\\n    posts      map[int]Post\\n    lastPostID int\\n    sync.Mutex\\n}\\n\\ntype Post struct {\\n    ID    int\\n    Title string\\n    Body  string\\n}\\n\\n// NewBlog is required because, even though Blog is exported its fields are not.\\n// The fields are internal to the package.\\nfunc NewBlog() *Blog {\\n    return &Blog{\\n        posts: make(map[int]Post),\\n    }\\n}\\n\")), mdx(\"p\", null, \"The function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"NewBlog() *Blog\"), \" is necessary since we aren't exporting its fields: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"posts\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"lastPostID\"), \".\"), mdx(\"h5\", null, \"b. Methods\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Blog\"), \" will have two methods: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AddPost\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"GetPostByID\"), \". Notice the function signature.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"func (b *Blog) AddPost(payload, reply *Post) error {\\n    b.Lock()\\n    defer b.Unlock()\\n\\n    if payload.Title == \\\"\\\" || payload.Body == \\\"\\\" {\\n        return errors.New(\\\"Title and Body must not be empty\\\")\\n    }\\n\\n    b.lastPostID++\\n\\n    *reply = Post{ID: b.lastPostID, Title: payload.Title, Body: payload.Body}\\n    b.posts[reply.ID] = *reply\\n\\n    return nil\\n}\\n\\nfunc (b *Blog) GetPostByID(payload int, reply *Post) error {\\n    b.Lock()\\n    defer b.Unlock()\\n\\n    *reply = b.posts[payload]\\n\\n    return nil\\n}\\n\")), mdx(\"p\", null, \"Each method takes two arguments, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"payload\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reply\"), \" (you can name them anything). It receives the input from the client in the first parameter. The second argument (a pointer) is used for sending a response back to the client.\"), mdx(\"h5\", null, \"c. Server\"), mdx(\"p\", null, \"The server implementation is fairly simple:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// Fetch an instance of the object\\nblog := types.NewBlog()\\n\\nrpc.Register(blog) // Register the instance with the rpc\\nrpc.HandleHTTP() // Configure the rpc to serve over HTTP\\n\\nerr := http.ListenAndServe(\\\":3000\\\", nil)\\nif err != nil {\\n    log.Fatalln(\\\"Error starting the RPC server\\\", err)\\n}\\n\")), mdx(\"h5\", null, \"d. Client\"), mdx(\"p\", null, \"Dial the server using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc.DialHTTP\"), \":\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"client, err := rpc.DialHTTP(\\\"tcp\\\", \\\":3000\\\")\\nif err != nil {\\n    log.Fatalln(\\\"Error creating the RPC client\\\", err)\\n}\\n\")), mdx(\"p\", null, \"And make the remote procedure calls using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"client.Call\"), \". It takes three arguments:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"The method name of the form: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"<T>.<MethodName>\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Input params\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A pointer to receive the response from the server\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-go\"\n  }, \"// Create a post\\nvar post types.Post\\n\\n// Create posts\\nerr = client.Call(\\\"Blog.AddPost\\\", &types.Post{Title: \\\"post 1\\\", Body: \\\"Hello, world!\\\"}, &post)\\nif err != nil {\\n    log.Fatalln(\\\"Error creating post\\\", err)\\n}\\nlog.Printf(\\\"[AddPost] ID: %d | Title: %s | Body: %s\\\\n\\\", post.ID, post.Title, post.Body)\\n\\n// Fetch a post by ID\\nerr = client.Call(\\\"Blog.GetPostByID\\\", 3, &post)\\nif err != nil {\\n    log.Fatalln(\\\"Error creating post\\\", err)\\n}\\nlog.Printf(\\\"[GetPostByID] ID: %d | Title: %s | Body: %s\\\\n\\\", post.ID, post.Title, post.Body)\\n\")), mdx(\"p\", null, \"The entire code can be found on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/bensooraj/blog-code-resource-repo/tree/main/borneo\"\n  }, \"Github\"), \".\"), mdx(\"h3\", null, \"Some thoughts\"), mdx(\"p\", null, \"In our implementation, the initial handshake between the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" client and server are negotiated over HTTP. Thereafter, the HTTP server acts like a proxy or a conduit between the two, a concept known as \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/HTTP_tunnel\"\n  }, \"HTTP tunneling\"), \". I believe this can be customized.\"), mdx(\"p\", null, \"It can be difficult to standardize (to follow common semantics) RPC implementations. This gap is what projects like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"gRPC\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"dRPC\"), \" etc. attepmt to solve.\"), mdx(\"p\", null, \"It should be obvious by now that you can register only one object with a given name with the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"rpc\"), \" server.\"), mdx(\"p\", null, \"Further reading:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://golang.org/pkg/net/rpc/\"\n  }, \"godoc: Package \", mdx(\"inlineCode\", {\n    parentName: \"a\"\n  }, \"rpc\"))), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://grpc.io/\"\n  }, \"gRPC: A high performance, open source universal RPC framework\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://github.com/storj/drpc\"\n  }, \"dRPC: A lightweight, drop-in replacement for gRPC\"))), mdx(\"hr\", null), mdx(\"p\", null, \"Note: \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"This article is not an in-depth tutorial or treatment of Golang's syntax, semantics, design or implementation, but a journal of my learnings.\")));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Introduction Go's  rpc  package enables communication across multiple machines, sort of like inter-process communication via funtion/method…","timeToRead":2,"banner":null}},"pageContext":{"slug":"/go-rp-cs-remote-procedure-calls","formatString":"DD.MM.YYYY"}},"staticQueryHashes":["3090400250","3090400250","318001574"]}